<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Wonder World (Alpha)</title>
    <style>
    body {
        margin: 0;
        overflow: hidden;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
    }
    #info {
        position: absolute;
        top: 0;
        width: 100%;
        color: #fff;
        font-family: sans-serif;
        padding: 10px;
        z-index: 1;
    }
    /* New underwater overlay styles */
    #underwater-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(51,102,255,0.5); /* blue transparent overlay */
        pointer-events: none;
        z-index: 999;
        display: none;
    }

    </style>
</head>
<body>
    <div id="info">
    Wonder World Version Alpha.8.3.6
    </div>
    <!-- New underwater overlay element -->
    <div id="underwater-overlay"></div>
    <!-- Load Three.js from a CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- ImprovedNoise with Random Permutation -->
    <script>
    const none = null;
    
    // Add a seeded random generator function:
    function seededRandomGenerator(seed) {
        var m = 0x80000000; // 2^31
        var a = 1103515245;
        var c = 12345;
        var g = 7499755 * seed / c;
        var u = c - seed * g;

        var state = seed ? seed : Math.floor(g * m % seed);

        return function() {
            state = (a * (state ) + c) % m;
            return state / (m - 1);
        };
    }
    // Replace your ImprovedNoise implementation with:
    var ImprovedNoise = function () {
        var seededRandom = seededRandomGenerator(worldSeed);
        var p = [];
        // Use a seeded random permutation
        for (var i = 0; i < 256; i++) {
            p[i] = Math.floor(seededRandom() * 256);
        }
        var permutation = new Array(512);
        for (var i = 0; i < 256; i++) {
            permutation[i] = p[i];
            permutation[i + 256] = p[i];
        }
        function fade(t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
        }
        function lerp(t, a, b) {
            return a + t * (b - a);
        }
        function grad(hash, x, y, z) {
            var h = hash & 15;
            var u = h < 8 ? x : y;
            var v = h < 4 ? y : (h === 12 || h === 14 ? x : z);
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }
        return {
            noise: function (x, y, z) {
                var floorX = Math.floor(x),
                    floorY = Math.floor(y),
                    floorZ = Math.floor(z);
                var X = floorX & 255,
                    Y = floorY & 255,
                    Z = floorZ & 255;
                x -= floorX;
                y -= floorY;
                z -= floorZ;
                var u = fade(x),
                    v = fade(y),
                    w = fade(z);
                var A = permutation[X] + Y,
                    AA = permutation[A] + Z,
                    AB = permutation[A + 1] + Z;
                var B = permutation[X + 1] + Y,
                    BA = permutation[B] + Z,
                    BB = permutation[B + 1] + Z;
                return lerp(
                    w,
                    lerp(
                        v,
                        lerp(u, grad(permutation[AA], x, y, z), grad(permutation[BA], x - 1, y, z)),
                        lerp(u, grad(permutation[AB], x, y - 1, z), grad(permutation[BB], x - 1, y - 1, z))
                    ),
                    lerp(
                        v,
                        lerp(u, grad(permutation[AA + 1], x, y, z - 1), grad(permutation[BA + 1], x - 1, y, z - 1)),
                        lerp(u, grad(permutation[AB + 1], x, y - 1, z - 1), grad(permutation[BB + 1], x - 1, y - 1, z - 1))
                    )
                );
            }
        };
    };
    </script>

    <!-- Main Game Script -->
    <script>
    /********************************************
     * World Data
     ********************************************/
    // Global World Constants & Variables
    const CHUNK_SIZE = 16;         // Blocks per side of a chunk
    const WORLD_HEIGHT = 216;        // Vertical blocks per chunk
    const WORLD_CHUNK_COUNT = 100;   // World chunk grid
    const VISIBLE_RADIUS = 6;        // Load chunks within a certain radius

    // Biome Data  
    /********************************************
     * Important Biome Data Notes:
     * 
     *   **TRANSITION** The transition value can be set to "None", "Mostly", or "Full"
     *   "None" means no transition between biomes. It may look a bit choppy for some biomes.
     *   "Mostly" means that the transition between biomes is mostly smooth. Some sections may look choppy while others are smooth.
     *   "Full" means that the transition between biomes is very smooth. Great for mountains and such.
     * 
     *   **LAYERS** The layers value is an array of objects. Each object has a type and number value.
     *   The layers are rendered from top to bottom till either the layer placing is complete, or reaches the very bottom of the chunk.
     *   If the layers are completed, the defaultLayer is used for the remaining blocks.
     * 
     *   The type is the block type. The number is the number of blocks of the type.
     *   The number can be a solid number made using an integer, or a string.
     *   There are three types of strings:
     *   Range "[min]-[max]": The number of blocks will be a random number between min and max.
     *   Single Number "[number]": The number of blocks will be number.
     *   Coordinates "$[yMin]-[yMax]": The number of blocks will be a random number between min and max.
     *********************************************/
    const BIOMES = {
        plains: {
            baseHeight: 55, // Base height for this biome
            heightVariation: 2, // Hill height
            frequency: 0.05, // Hill spread
            rarity: 80, // Frequency of biome (0-100)
            transition: "Full", // The rate of transition between neighboring biomes
            size: 0.5, // The size of the biome
            fill: none, // Fill the open area with the specified block under the number.
            defaultLayer: "stone", // Default block type for this biome
            layers: [
                { type: "dirt", number: "2-5" },
            ],
            structures: [
                { type: "tree", frequency: 0.05 },
                { type: "house", frequency: 0.001 }
            ]
        },
        hills: {
            baseHeight: 75, // Base height for this biome
            heightVariation: 8, // Hill height
            frequency: 0.05, // Hill spread
            rarity: 60, // Frequency of biome (0-100)
            transition: "Smooth", // The rate of transition between neighboring biomes
            size: 0.5, // The size of the biome
            fill: none, // Fill the open area with the specified block under the number.
            defaultLayer: "stone", // Default block type for this biome
            layers: [
                
            ],
            structures: [
                { type: "tree", frequency: 0.02 },
            ]
        },
        ocean: {
            baseHeight: 15, // Base height for this biome
            heightVariation: 20, // Hill height
            frequency: 0.02, // Hill spread
            rarity: 60, // Frequency of biome (0-100)
            transition: "Smooth", // The rate of transition between neighboring biomes
            size: 0.8, // The size of the biome
            fill: { type: "water", height: 40 }, // Fill the open area with the specified block under the height.
            defaultLayer: "stone", // Default block type for this biome
            layers: [
                { type: "sand", number: "5-12" },
            ],
        }
    };

    // Add a mapping for block type strings
    const BLOCK_TYPES = {
        stone: 1,
        dirt: 2,
        wood: 3,
        leaves: 4,
        sand: 5,
        snow: 6,
        water: 7 // new water block type
    };

    // Updated blockColors to use block type names with Color and transparency properties.
    const blockColors = {
        stone: { color: new THREE.Color(0x888888), transparency: 1, sideRendering: "one" },
        dirt: { color: new THREE.Color(0x664422), transparency: 1, sideRendering: "one" },
        wood: { color: new THREE.Color(0x885522), transparency: 1, sideRendering: "one" },
        leaves: { color: new THREE.Color(0x88cc88), transparency: 1, sideRendering: "one" },
        sand: { color: new THREE.Color(0xD2B48C), transparency: 1, sideRendering: "one" },
        snow: { color: new THREE.Color(0xFFFFFF), transparency: 1, sideRendering: "one" },
        water: { color: new THREE.Color(0x3366FF), transparency: 0.7, sideRendering: "both" } // water is transparent
    };

    // Helper to map BLOCK_TYPES number back to its name.
    function getBlockName(blockTypeNumber) {
        return Object.keys(BLOCK_TYPES).find(key => BLOCK_TYPES[key] === blockTypeNumber);
    }

    // Player collision and movement parameters.
    const playerHeight = 1.8;       
    const playerRadius = 0.3;       
    const jumpImpulse = 13; 
    const worldSeed = 1;        

    // Global variables for rendering, scene, and input.
    let scene, renderer;
    let camera, yawObject;
    let pitch = 0;
    let controlsEnabled = false;
    let velocity = new THREE.Vector3();
    let prevTime = performance.now();
    let moveForward = false,
        moveBackward = false,
        moveLeft = false,
        moveRight = false;
    let canJump = false;
    let lastPlayerChunkX = null, lastPlayerChunkZ = null;
    let loadedChunks = {};    // keys: "cx,cz" -> mesh
    let chunkDataStore = {};  // keys: "cx,cz" -> 3D block array

    // Noise generator and raycaster for block interactions.
    const noiseGenerator = new ImprovedNoise();
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    // Global running detection.
    let lastWPressTime = 0;
    let isRunning = false;

    // Add global flying variables:
    let isFlying = false;
    let lastJumpTapTime = 0;
    let flyUp = false;
    let flyDown = false;

    // Add global game mode variable (default "normal")
    let gameMode = "normal"; // "normal" or "spectator"

    const KEY = {}

    // Remove pointer lock if any touch event occurs:
    document.addEventListener("touchstart", function(e) {
        if (document.pointerLockElement) {
            document.exitPointerLock();
        }
    }, { passive: true });

    // BEGIN new 8-button movement controls and jump button

    // Create container for left directional buttons
    const leftControlContainer = document.createElement("div");
    leftControlContainer.style.position = "absolute";
    leftControlContainer.style.left = "20px";
    leftControlContainer.style.bottom = "20px";
    leftControlContainer.style.width = "150px";
    leftControlContainer.style.height = "150px";
    document.body.appendChild(leftControlContainer);

    // Define the 8 directions with corresponding vectors and angles.
    const directions = [
        { name: "forward", vx: 0, vy: -1, angle: 90 },
        { name: "forwardRight", vx: 1, vy: -1, angle: 45 },
        { name: "right", vx: 1, vy: 0, angle: 0 },
        { name: "backRight", vx: 1, vy: 1, angle: 315 },
        { name: "back", vx: 0, vy: 1, angle: 270 },
        { name: "backLeft", vx: -1, vy: 1, angle: 225 },
        { name: "left", vx: -1, vy: 0, angle: 180 },
        { name: "forwardLeft", vx: -1, vy: -1, angle: 135 }
    ];
    directions.forEach(dir => {
        const btn = document.createElement("div");
        btn.id = "btn-" + dir.name;
        btn.innerHTML = dir.name;
        btn.style.position = "absolute";
        btn.style.width = "40px";
        btn.style.height = "40px";
        btn.style.background = "rgba(0,0,0,0.5)";
        btn.style.color = "#fff";
        btn.style.textAlign = "center";
        btn.style.lineHeight = "40px";
        btn.style.borderRadius = "50%";
        // Position buttons on a circle within the container
        const radius = 50;
        const centerX = 75;
        const centerY = 75;
        const rad = dir.angle * Math.PI/180;
        btn.style.left = (centerX + radius * Math.cos(rad) - 20) + "px";
        btn.style.top = (centerY - radius * Math.sin(rad) - 20) + "px";
        // On touchstart, set movement flags according to the direction.
        btn.addEventListener("touchstart", function(e) {
            e.preventDefault();
            moveForward = (dir.vy < 0);
            moveBackward = (dir.vy > 0);
            moveRight = (dir.vx > 0);
            moveLeft = (dir.vx < 0);
        }, false);
        btn.addEventListener("touchend", function(e) {
            e.preventDefault();
            moveForward = moveBackward = moveRight = moveLeft = false;
        }, false);
        leftControlContainer.appendChild(btn);
    });

    // Create jump button on the right side
    const jumpButton = document.createElement("div");
    jumpButton.style.position = "absolute";
    jumpButton.style.right = "20px";
    jumpButton.style.bottom = "20px";
    jumpButton.style.width = "80px";
    jumpButton.style.height = "80px";
    jumpButton.style.background = "rgba(0,0,0,0.5)";
    jumpButton.style.borderRadius = "50%";
    jumpButton.style.textAlign = "center";
    jumpButton.style.lineHeight = "80px";
    jumpButton.style.fontSize = "20px";
    jumpButton.innerHTML = "Jump";
    document.body.appendChild(jumpButton);
    jumpButton.addEventListener("touchstart", function(e) {
        e.preventDefault();
        if (canJump) {
            velocity.y = jumpImpulse;
            canJump = false;
        }
    }, false);

    // Global screen touch for camera control (excluding the two button areas)
    let cameraTouchStart = null;
    document.addEventListener("touchstart", function(e) {
        if (e.target !== leftControlContainer &&
            e.target !== jumpButton &&
            e.target.parentNode !== leftControlContainer) {
                cameraTouchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
    }, false);
    document.addEventListener("touchmove", function(e) {
        if (cameraTouchStart &&
            e.target !== leftControlContainer &&
            e.target !== jumpButton &&
            e.target.parentNode !== leftControlContainer) {
                let dx = e.touches[0].clientX - cameraTouchStart.x;
                let dy = e.touches[0].clientY - cameraTouchStart.y;
                yawObject.rotation.y -= dx * 0.005;
                pitch -= dy * 0.005;
                pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
                camera.rotation.x = pitch;
                cameraTouchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                e.preventDefault();
        }
    }, false);
    document.addEventListener("touchend", function(e) {
        cameraTouchStart = null;
    }, false);

    // END new touch button controls

    /********************************************
     * Methods
     ********************************************/
    // Cylinder-Based Collision Helpers
    function collidesCylinder(posY, posX, posZ) {
        const baseY = posY;
        const topY = posY + playerHeight;
        for (let bx = Math.floor(posX - playerRadius); bx <= Math.floor(posX + playerRadius); bx++) {
            for (let bz = Math.floor(posZ - playerRadius); bz <= Math.floor(posZ + playerRadius); bz++) {
                for (let by = Math.floor(baseY); by < Math.floor(topY) + 1; by++) {
                    // changed code: ignore water blocks
                    const block = getBlockAt(bx, by, bz);
                    if (block && block !== BLOCK_TYPES.water) {
                        if ((by < topY) && (by + 1 > baseY)) {
                            const nearestX = Math.max(bx, Math.min(posX, bx + 1));
                            const nearestZ = Math.max(bz, Math.min(posZ, bz + 1));
                            const dx = posX - nearestX;
                            const dz = posZ - nearestZ;
                            if (Math.sqrt(dx * dx + dz * dz) < playerRadius) return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    function resolveHorizontalCollisions() {
        let iterations = 0;
        while (iterations < 5) {
            let posX = yawObject.position.x;
            let posZ = yawObject.position.z;
            let correction = new THREE.Vector2(0, 0);
            let collided = false;
            const baseY = yawObject.position.y;
            const topY = baseY + playerHeight;
            for (let bx = Math.floor(posX - playerRadius); bx <= Math.floor(posX + playerRadius); bx++) {
                for (let bz = Math.floor(posZ - playerRadius); bz <= Math.floor(posZ + playerRadius); bz++) {
                    for (let by = Math.floor(baseY); by < Math.floor(topY) + 1; by++) {
                        // changed code: ignore water blocks
                        const block = getBlockAt(bx, by, bz);
                        if (block && block !== BLOCK_TYPES.water) {
                            if ((by < topY) && (by + 1 > baseY)) {
                                const nearestX = Math.max(bx, Math.min(posX, bx + 1));
                                const nearestZ = Math.max(bz, Math.min(posZ, bz + 1));
                                let dx = posX - nearestX;
                                let dz = posZ - nearestZ;
                                let dist = Math.sqrt(dx * dx + dz * dz);
                                if (dist < playerRadius) {
                                    let overlap = playerRadius - dist;
                                    if (dist === 0) {
                                        dx = 0.01;
                                        dz = 0.01;
                                        dist = Math.sqrt(dx * dx + dz * dz);
                                    }
                                    const nx = dx / dist;
                                    const nz = dz / dist;
                                    correction.x += nx * overlap;
                                    correction.y += nz * overlap;
                                    collided = true;
                                }
                            }
                        }
                    }
                }
            }
            if (collided) {
                yawObject.position.x += correction.x;
                yawObject.position.z += correction.y;
            } else {
                break;
            }
            iterations++;
        }
    }

    // Block & Chunk Helpers
    function getBlockAt(globalX, globalY, globalZ) {
        if (globalY < 0 || globalY >= WORLD_HEIGHT) return 0;
        const cx = Math.floor(globalX / CHUNK_SIZE);
        const cz = Math.floor(globalZ / CHUNK_SIZE);
        if (cx < 0 || cx >= WORLD_CHUNK_COUNT || cz < 0 || cz >= WORLD_CHUNK_COUNT) return 0;
        
        // Get block from chunk data
        const key = `${cx},${cz}`;
        const chunkData = chunkDataStore[key];
        if (!chunkData) {
            // For unloaded chunks, we need to determine if this block would actually exist
            // Use the terrain generation logic to check if there would be a block here
            const height = getHeightWithBiome(globalX, globalZ);
            const biomeKey = getBiome(globalX, globalZ);
            const biome = BIOMES[biomeKey];
            
            // If it's below ground level, there would be a block here
            if (globalY < height) return BLOCK_TYPES[biome.defaultLayer];
            
            // Check for water fill in ocean biomes
            if (biome.fill && biome.fill.type === "water" && globalY < biome.fill.height) {
                return BLOCK_TYPES.water;
            }
            
            return 0; // Air above ground level
        }
        
        const localX = globalX - cx * CHUNK_SIZE;
        const localZ = globalZ - cz * CHUNK_SIZE;
        if (localX < 0 || localX >= CHUNK_SIZE || localZ < 0 || localZ >= CHUNK_SIZE) return 0;
        
        const block = chunkData[localX][globalY][localZ];
        return block;
    }

    function getBlockInChunk(chunkData, x, y, z) {
        if (y < 0 || y >= WORLD_HEIGHT) return 0;
        
        // If the coordinates are outside this chunk, use getBlockAt to check neighboring chunks
        if (x < 0 || x >= CHUNK_SIZE || z < 0 || z >= CHUNK_SIZE) {
            const cx = Math.floor(x / CHUNK_SIZE);
            const cz = Math.floor(z / CHUNK_SIZE);
            const globalX = x + chunkData.chunkX * CHUNK_SIZE;
            const globalZ = z + chunkData.chunkZ * CHUNK_SIZE;
            return getBlockAt(globalX, y, globalZ);
        }
        
        return chunkData[x][y][z];
    }

    const faces = [
        { // Left face (-X)
        dir: [-1, 0, 0],
        vertices: [
            [0, 0, 1],
            [0, 1, 1],
            [0, 1, 0],
            [0, 0, 0],
        ]
        },
        { // Right face (+X)
        dir: [1, 0, 0],
        vertices: [
            [1, 0, 0],
            [1, 1, 0],
            [1, 1, 1],
            [1, 0, 1],
        ]
        },
        { // Bottom face (-Y)
        dir: [0, -1, 0],
        vertices: [
            [0, 0, 0],
            [1, 0, 0],
            [1, 0, 1],
            [0, 0, 1],
        ]
        },
        { // Top face (+Y)
        dir: [0, 1, 0],
        vertices: [
            [0, 1, 1],
            [1, 1, 1],
            [1, 1, 0],
            [0, 1, 0],
        ]
        },
        { // Back face (-Z)
        dir: [0, 0, -1],
        vertices: [
            [1, 0, 0],
            [0, 0, 0],
            [0, 1, 0],
            [1, 1, 0],
        ]
        },
        { // Front face (+Z)
        dir: [0, 0, 1],
        vertices: [
            [0, 0, 1],
            [1, 0, 1],
            [1, 1, 1],
            [0, 1, 1],
        ]
        }
    ];

    function getHeight(globalX, globalZ) {
        const frequency = 0.05;
        let noiseVal = noiseGenerator.noise(globalX * frequency, 0, globalZ * frequency);
        return Math.floor(((noiseVal + 1) / 2) * (WORLD_HEIGHT - 1));
    }

    function getBiome(globalX, globalZ) {
        let n = (noiseGenerator.noise(globalX * 0.001, 0, globalZ * 0.001) + 1) / 2;
        let total = 0;
        for (const key in BIOMES) {
            total += BIOMES[key].rarity * BIOMES[key].size;
        }
        let threshold = n * total;
        let cumulative = 0;
        for (const key in BIOMES) {
            cumulative += BIOMES[key].rarity * BIOMES[key].size;
            if (threshold <= cumulative) {
                return key;
            }
        }
        return "ocean"; // fallback option
    }

    function getHeightWithBiome(globalX, globalZ) {
        const currentBiomeKey = getBiome(globalX, globalZ);
        const currentBiome = BIOMES[currentBiomeKey];
        if (currentBiome.transition === "None") {
            const nPrimary = noiseGenerator.noise(globalX * currentBiome.frequency, 0, globalZ * currentBiome.frequency);
            return Math.floor(currentBiome.baseHeight + nPrimary * currentBiome.heightVariation);
        } else {
            // Set blend radius based on transition rate:
            // "Full" gets a larger blend radius for greater smoothness, "Mostly" less so.
            const blendRadius = (currentBiome.transition === "Full") ? 10 : 5;
            let sumHeights = 0;
            let totalWeight = 0;
            // Sample nearby points to blend heights between biomes.
            for (let dx = -blendRadius; dx <= blendRadius; dx++) {
                for (let dz = -blendRadius; dz <= blendRadius; dz++) {
                    const sampleBiomeKey = getBiome(globalX + dx, globalZ + dz);
                    const sampleBiome = BIOMES[sampleBiomeKey];
                    const nSample = noiseGenerator.noise((globalX + dx) * sampleBiome.frequency, 0, (globalZ + dz) * sampleBiome.frequency);
                    const sampleHeight = sampleBiome.baseHeight + nSample * sampleBiome.heightVariation;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    const weight = Math.max(0, blendRadius - distance + 1);
                    sumHeights += sampleHeight * weight;
                    totalWeight += weight;
                }
            }
            return Math.floor(sumHeights / totalWeight);
        }
    }

    // Structure Generation
    function generateTree(data, x, y, z) {
        // Simple tree structure: trunk and leaves
        for (let i = 0; i < 4; i++) {
            if (y + i < WORLD_HEIGHT) data[x][y + i][z] = 3; // Trunk
        }
        for (let dx = -1; dx <= 1; dx++) {
            for (let dz = -1; dz <= 1; dz++) {
                if (x + dx >= 0 && x + dx < CHUNK_SIZE && z + dz >= 0 && z + dz < CHUNK_SIZE) {
                    if (y + 4 < WORLD_HEIGHT) data[x + dx][y + 4][z + dz] = 4; // Leaves
                }
            }
        }
    }

    function generateHouse(data, x, y, z, size=6) {
        // Simple house structure: walls and roof
        for (let dx = 0; dx < size; dx++) {
            for (let dz = 0; dz < size; dz++) {
                for (let dy = 0; dy < size; dy++) {
                    if (x + dx < CHUNK_SIZE && z + dz < CHUNK_SIZE && y + dy < WORLD_HEIGHT) {
                        if (dx === 0 || dx === size-1 || dz === 0 || dz === size-1) {
                            data[x + dx][y + dy][z + dz] = 1; // Walls
                        }
                    }
                }
            }
        }
        for (let dx = 0; dx < size; dx++) {
            for (let dz = 0; dz < size; dz++) {
                if (x + dx < CHUNK_SIZE && z + dz < CHUNK_SIZE && y + size < WORLD_HEIGHT) {
                    data[x + dx][y + size][z + dz] = 1; // Roof
                }
            }
        }
    }

    // Chunk Data Generation
    function generateChunkData(cx, cz) {
        const data = [];
        for (let x = 0; x < CHUNK_SIZE; x++) {
            data[x] = [];
            for (let y = 0; y < WORLD_HEIGHT; y++) {
                data[x][y] = [];
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    data[x][y][z] = 0; // Initialize all blocks as air
                }
            }
        }
        for (let x = 0; x < CHUNK_SIZE; x++) {
            for (let z = 0; z < CHUNK_SIZE; z++) {
                let globalX = cx * CHUNK_SIZE + x;
                let globalZ = cz * CHUNK_SIZE + z;
                // Select biome using smooth noise.
                let biomeKey = getBiome(globalX, globalZ);
                let biome = BIOMES[biomeKey];
                let h = getHeightWithBiome(globalX, globalZ);
                if (h < 0) h = 0;
                if (h >= WORLD_HEIGHT) h = WORLD_HEIGHT - 1;
                
                // Determine layered column for (x,z)
                let column = new Array(h).fill(0);
                let remaining = h;
                // Process the layers array from top to bottom.
                if (biome.layers && biome.layers.length > 0) {
                    for (let i = 0; i < biome.layers.length; i++) {
                        // Parse thickness: supports "range" like "2-5" or a fixed value "3" or coordinate format "$min-max"
                        let thicknessDef = biome.layers[i].number;
                        let thickness = 0;
                        if (typeof thicknessDef === "string") {
                            // Remove any leading '$' if present
                            thicknessDef = thicknessDef.startsWith("$") ? thicknessDef.slice(1) : thicknessDef;
                            if (thicknessDef.indexOf("-") !== -1) {
                                let parts = thicknessDef.split("-").map(s => parseInt(s));
                                thickness = Math.floor(Math.random() * (parts[1] - parts[0] + 1)) + parts[0];
                            } else {
                                thickness = parseInt(thicknessDef);
                            }
                        } else {
                            thickness = thicknessDef;
                        }
                        // Clamp thickness if more than remaining
                        if (thickness > remaining) thickness = remaining;
                        // Fill from (remaining - thickness) to (remaining - 1)
                        for (let y = remaining - thickness; y < remaining; y++) {
                            column[y] = BLOCK_TYPES[biome.layers[i].type];
                        }
                        remaining -= thickness;
                        if (remaining <= 0) break;
                    }
                }
                // Fill any remaining lower blocks with the defaultLayer.
                for (let y = 0; y < remaining; y++) {
                    column[y] = BLOCK_TYPES[biome.defaultLayer];
                }
                // Apply the column data into the chunk: y from 0 to h-1 gets set, others remain air.
                for (let y = 0; y < h; y++) {
                    data[x][y][z] = column[y];
                }

                // If biome.fill is defined, fill all air blocks from the very bottom to the fill height
                if (biome.fill) {
                    let fillHeight = Math.min(biome.fill.height, WORLD_HEIGHT);
                    console.log(fillHeight);
                    for (let y = 0; y < fillHeight; y++) {
                        for (let x = 0; x < CHUNK_SIZE; x++) {
                            for (let z = 0; z < CHUNK_SIZE; z++) {
                                if (data[x][y][z] === 0) {
                                    data[x][y][z] = BLOCK_TYPES[biome.fill.type];
                                }
                            }
                        }
                    }
                }

                // Generate structures based on biome data
                if (biome.structures && biome.structures.length != 0) {
                    biome.structures.forEach(structure => {
                        if (Math.random() < structure.frequency / 50) {
                            if (structure.type === "tree") {
                                generateTree(data, x, h, z);
                            } else if (structure.type === "house") {
                                generateHouse(data, x, h , z);
                            }
                        }
                    });
                }
            }
        }
        return data;
    }

    // Build Chunk Geometry with Vertex Colors
    function buildChunkGeometry(chunkData, cx, cz) {
        const oVertices = [], oIndices = [], oUVs = [], oColors = [];
        let oVertexCount = 0;
        const tVertices = [], tIndices = [], tUVs = [], tColors = [];
        let tVertexCount = 0;
        for (let x = 0; x < CHUNK_SIZE; x++) {
            for (let y = 0; y < WORLD_HEIGHT; y++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    let blockType = chunkData[x][y][z];
                    if (blockType === 0) continue;
                    for (let f = 0; f < faces.length; f++) {
                        const face = faces[f];
                        const nx = x + face.dir[0],
                              ny = y + face.dir[1],
                              nz = z + face.dir[2];
                        // Check neighbor from the current chunk; if out-of-bound, check global neighbor block
                        let neighbor;
                        if (nx < 0 || nx >= CHUNK_SIZE || nz < 0 || nz >= CHUNK_SIZE) {
                            const globalXBlock = cx * CHUNK_SIZE + x + face.dir[0];
                            const globalZBlock = cz * CHUNK_SIZE + z + face.dir[2];
                            neighbor = getBlockAt(globalXBlock, y, globalZBlock);
                        } else {
                            neighbor = getBlockInChunk(chunkData, nx, ny, nz);
                        }
                        // For non-water blocks, if the neighbor exists, skip face generation.
                        if (blockType !== BLOCK_TYPES.water && neighbor === BLOCK_TYPES.water) {
                            // Intentional fall-through
                        } else if (neighbor !== 0) {
                            continue;
                        }
                        const blockName = getBlockName(blockType);
                        const colObj = blockColors[blockName] || { color: new THREE.Color(0xffffff), transparency: 1 };
                        
                        if (colObj.transparency === 1) {
                            for (let i = 0; i < 4; i++) {
                                const vertex = face.vertices[i];
                                oVertices.push(
                                    cx * CHUNK_SIZE + x + vertex[0],
                                    y + vertex[1],
                                    cz * CHUNK_SIZE + z + vertex[2]
                                );
                                oColors.push(colObj.color.r, colObj.color.g, colObj.color.b);
                            }
                            oUVs.push(0, 0, 1, 0, 1, 1, 0, 1);
                            oIndices.push(
                                oVertexCount, oVertexCount + 1, oVertexCount + 2,
                                oVertexCount, oVertexCount + 2, oVertexCount + 3
                            );
                            oVertexCount += 4;
                        } else {
                            for (let i = 0; i < 4; i++) {
                                const vertex = face.vertices[i];
                                tVertices.push(
                                    cx * CHUNK_SIZE + x + vertex[0],
                                    y + vertex[1],
                                    cz * CHUNK_SIZE + z + vertex[2]
                                );
                                tColors.push(colObj.color.r, colObj.color.g, colObj.color.b);
                            }
                            tUVs.push(0, 0, 1, 0, 1, 1, 0, 1);
                            tIndices.push(
                                tVertexCount, tVertexCount + 1, tVertexCount + 2,
                                tVertexCount, tVertexCount + 2, tVertexCount + 3
                            );
                            tVertexCount += 4;
                        }
                    }
                }
            }
        }
        let opaqueGeometry = null, transparentGeometry = null;
        if (oVertices.length) {
            opaqueGeometry = new THREE.BufferGeometry();
            opaqueGeometry.setAttribute("position", new THREE.Float32BufferAttribute(oVertices, 3));
            opaqueGeometry.setAttribute("uv", new THREE.Float32BufferAttribute(oUVs, 2));
            opaqueGeometry.setAttribute("color", new THREE.Float32BufferAttribute(oColors, 3));
            opaqueGeometry.setIndex(oIndices);
            opaqueGeometry.computeVertexNormals();
        }
        if (tVertices.length) {
            transparentGeometry = new THREE.BufferGeometry();
            transparentGeometry.setAttribute("position", new THREE.Float32BufferAttribute(tVertices, 3));
            transparentGeometry.setAttribute("uv", new THREE.Float32BufferAttribute(tUVs, 2));
            transparentGeometry.setAttribute("color", new THREE.Float32BufferAttribute(tColors, 3));
            transparentGeometry.setIndex(tIndices);
            transparentGeometry.computeVertexNormals();
        }
        return { opaque: opaqueGeometry, transparent: transparentGeometry };
    }

    // Chunk Management
    function loadChunk(cx, cz) {
        const key = `${cx},${cz}`;
        if (loadedChunks[key]) return;
        const chunkData = generateChunkData(cx, cz);
        chunkDataStore[key] = chunkData;
        const geoms = buildChunkGeometry(chunkData, cx, cz);
        const group = new THREE.Group();
        if (geoms.opaque) {
            const opaqueMaterial = new THREE.MeshLambertMaterial({
                vertexColors: true,
                side: THREE.FrontSide, // opaque blocks use one-sided rendering
                transparent: false
            });
            group.add(new THREE.Mesh(geoms.opaque, opaqueMaterial));
        }
        if (geoms.transparent) {
            const transparentMaterial = new THREE.MeshLambertMaterial({
                vertexColors: true,
                side: blockColors.water.sideRendering === "both" ? THREE.DoubleSide : THREE.FrontSide,
                transparent: true,
                depthWrite: false,
                opacity: blockColors.water.transparency
            });
            group.add(new THREE.Mesh(geoms.transparent, transparentMaterial));
        }
        scene.add(group);
        loadedChunks[key] = group;
    }

    function unloadChunk(cx, cz) {
        const key = `${cx},${cz}`;
        if (loadedChunks[key]) {
            scene.remove(loadedChunks[key]);
            loadedChunks[key].traverse(obj => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });
            delete loadedChunks[key];
            delete chunkDataStore[key];
        }
    }

    function updateChunk(cx, cz) {
        const key = `${cx},${cz}`;
        if (!chunkDataStore[key]) return;
        if (loadedChunks[key]) {
            scene.remove(loadedChunks[key]);
            loadedChunks[key].traverse(obj => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });
        }
        const geoms = buildChunkGeometry(chunkDataStore[key], cx, cz);
        const group = new THREE.Group();
        if (geoms.opaque) {
            const opaqueMaterial = new THREE.MeshLambertMaterial({
                vertexColors: true,
                side: THREE.FrontSide,
                transparent: false
            });
            group.add(new THREE.Mesh(geoms.opaque, opaqueMaterial));
        }
        if (geoms.transparent) {
            const transparentMaterial = new THREE.MeshLambertMaterial({
                vertexColors: true,
                side: blockColors.water.sideRendering === "both" ? THREE.DoubleSide : THREE.FrontSide,
                transparent: true,
                depthWrite: false,
                opacity: blockColors.water.transparency
            });
            group.add(new THREE.Mesh(geoms.transparent, transparentMaterial));
        }
        scene.add(group);
        loadedChunks[key] = group;
    }

    // Add chunk loading queue system
    const chunkLoadQueue = [];
    const MAX_CHUNKS_PER_FRAME = 2; // Adjust this value to balance performance
    
    function queueChunkLoad(cx, cz) {
        const key = `${cx},${cz}`;
        if (loadedChunks[key] || chunkLoadQueue.some(item => item.key === key)) return;
        chunkLoadQueue.push({ cx, cz, key });
    }
    
    function processChunkQueue() {
        let processedCount = 0;
        while (chunkLoadQueue.length > 0 && processedCount < MAX_CHUNKS_PER_FRAME) {
            const { cx, cz, key } = chunkLoadQueue.shift();
            if (!loadedChunks[key]) {
                const chunkData = generateChunkData(cx, cz);
                chunkDataStore[key] = chunkData;
                const geoms = buildChunkGeometry(chunkData, cx, cz);
                const group = new THREE.Group();

                const opaqueMaterial = new THREE.MeshLambertMaterial({
                    vertexColors: true,
                    side: THREE.FrontSide,
                    transparent: false
                });
                const transparentMaterial = new THREE.MeshLambertMaterial({
                    vertexColors: true,
                    side: blockColors.water.sideRendering === "both" ? THREE.DoubleSide : THREE.FrontSide,
                    transparent: true,
                    depthWrite: false,
                    opacity: blockColors.water.transparency
                });

                if (geoms.opaque) {
                    group.add(new THREE.Mesh(geoms.opaque, opaqueMaterial));
                }
                if (geoms.transparent) {
                    group.add(new THREE.Mesh(geoms.transparent, transparentMaterial));
                }
                
                // Add fade-in effect
                group.traverse(child => {
                    if (child instanceof THREE.Mesh) {
                        child.material.opacity = 0;
                        child.material.transparent = true;
                    }
                });
                
                scene.add(group);
                loadedChunks[key] = group;
                
                // Animate chunk fade-in
                const startTime = performance.now();
                const fadeInDuration = 500; // milliseconds
                function fadeIn() {
                    const elapsed = performance.now() - startTime;
                    const progress = Math.min(elapsed / fadeInDuration, 1);
                    group.traverse(child => {
                        if (child instanceof THREE.Mesh) {
                            if (child.material.userData.originalOpacity === undefined) {
                                child.material.userData.originalOpacity = child.material === transparentMaterial ? 
                                    blockColors.water.transparency : 1;
                            }
                            child.material.opacity = progress * child.material.userData.originalOpacity;
                        }
                    });
                    if (progress < 1) {
                        requestAnimationFrame(fadeIn);
                    } else {
                        group.traverse(child => {
                            if (child instanceof THREE.Mesh && child.material.userData.originalOpacity === 1) {
                                child.material.transparent = false;
                            }
                        });
                    }
                }
                fadeIn();
                processedCount++;
            }
        }
    }
    
    function updateChunks() {
        const playerPos = yawObject.position;
        let playerChunkX = Math.floor(playerPos.x / CHUNK_SIZE);
        let playerChunkZ = Math.floor(playerPos.z / CHUNK_SIZE);
        playerChunkX = Math.max(0, Math.min(WORLD_CHUNK_COUNT - 1, playerChunkX));
        playerChunkZ = Math.max(0, Math.min(WORLD_CHUNK_COUNT - 1, playerChunkZ));

        // Queue chunks in a spiral pattern from nearest to farthest
        const spiralOffsets = [];
        for (let radius = 0; radius <= VISIBLE_RADIUS; radius++) {
            for (let x = -radius; x <= radius; x++) {
                for (let z = -radius; z <= radius; z++) {
                    if (Math.max(Math.abs(x), Math.abs(z)) === radius) {
                        spiralOffsets.push({x, z});
                    }
                }
            }
        }
        
        for (const offset of spiralOffsets) {
            const cx = playerChunkX + offset.x;
            const cz = playerChunkZ + offset.z;
            if (cx >= 0 && cx < WORLD_CHUNK_COUNT && cz >= 0 && cz < WORLD_CHUNK_COUNT) {
                queueChunkLoad(cx, cz);
            }
        }

        // Unload distant chunks
        for (const key in loadedChunks) {
            const [cx, cz] = key.split(",").map(Number);
            const dx = cx - playerChunkX;
            const dz = cz - playerChunkZ;
            if (Math.max(Math.abs(dx), Math.abs(dz)) > VISIBLE_RADIUS + 1) {
                unloadChunk(cx, cz);
            }
        }
    }
    
    // Block Modification (Place / Break)
    function modifyBlockAt(worldPos, value) {
        // In spectator mode, disable interactions.
        if (gameMode === "spectator") return;
        const gx = Math.floor(worldPos.x);
        const gy = Math.floor(worldPos.y);
        const gz = Math.floor(worldPos.z);
        const cx = Math.floor(gx / CHUNK_SIZE);
        const cz = Math.floor(gz / CHUNK_SIZE);
        const key = `${cx},${cz}`;
        if (!chunkDataStore[key]) {
        console.log("Chunk not loaded. Cannot modify block.");
        return;
        }
        const localX = gx - cx * CHUNK_SIZE;
        const localZ = gz - cz * CHUNK_SIZE;
        if (
        localX < 0 || localX >= CHUNK_SIZE ||
        gy < 0 || gy >= WORLD_HEIGHT ||
        localZ < 0 || localZ >= CHUNK_SIZE
        ) {
        console.log("Block coordinates out of range.");
        return;
        }
        chunkDataStore[key][localX][gy][localZ] = value;
        updateChunk(cx, cz);
    }

    // Initialization & Rendering & Input Handling
    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x88ccff);
        scene.fog = new THREE.Fog(0x88ccff, 0, 150);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 0.5);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -8;
        directionalLight.shadow.camera.right = 8;
        directionalLight.shadow.camera.top = 8;
        directionalLight.shadow.camera.bottom = -8;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        scene.add(directionalLight);

        // Set up camera and first-person hierarchy.
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Position the camera at 80% of the cylinder height (simulating the head).
        camera.position.set(0, 0.8 * playerHeight, 0);
        yawObject = new THREE.Object3D();
        
        // Place the player near the center of the world; get ground height at starting x/z.
        let startX = (WORLD_CHUNK_COUNT * CHUNK_SIZE) / 2;
        let startZ = (WORLD_CHUNK_COUNT * CHUNK_SIZE) / 2;
        // If the default position is ocean, offset coordinates to land
        if (getBiome(startX, startZ) === "ocean") {
            startX += CHUNK_SIZE;
            startZ += CHUNK_SIZE;
        }
        let groundY = getHeightWithBiome(startX, startZ);
        yawObject.position.set(startX, groundY + playerHeight, startZ);
        // Remove direct addition of camera and add it to a new holder for water effect
        cameraEffect = new THREE.Object3D();
        cameraEffect.add(camera);
        yawObject.add(cameraEffect);
        scene.add(yawObject);
        
        // Preload visible chunks so the world is ready.
        updateChunks();
        
        // Setup Pointer Lock.
        const element = document.body;
        element.addEventListener("click", function () {
        element.requestPointerLock();
        });
        document.addEventListener("pointerlockchange", onPointerLockChange, false);
        document.addEventListener("pointerlockerror", onPointerLockError, false);
        document.addEventListener("mousemove", onMouseMove, false);
        document.addEventListener("mousedown", onMouseDown, false);
        window.addEventListener("keydown", onKeyDown, false);
        window.addEventListener("keyup", onKeyUp, false);
        window.addEventListener("resize", onWindowResize, false);

        animate();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onPointerLockChange() {
        controlsEnabled = (document.pointerLockElement === document.body);
    }
    function onPointerLockError() {
        console.error("PointerLock Error");
    }
    function onMouseMove(event) {
        if (!controlsEnabled) return;
        const movementX = event.movementX || 0;
        const movementY = event.movementY || 0;
        yawObject.rotation.y -= movementX * 0.002;
        pitch -= movementY * 0.002;
        pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
        camera.rotation.x = pitch;
    }

    function getMovementAcceleration(delta) {
        var transportationSpeed = 1;
        if (isFlying) {
            transportationSpeed = 2;
        }
        const forward = new THREE.Vector3(0, 0, -1)
        .applyAxisAngle(new THREE.Vector3(0, 1, 0), yawObject.rotation.y);
        const right = new THREE.Vector3(1, 0, 0)
        .applyAxisAngle(new THREE.Vector3(0, 1, 0), yawObject.rotation.y);
        const accel = new THREE.Vector3();
        if (moveForward) accel.add(forward);
        if (moveBackward) accel.sub(forward);
        if (moveLeft) accel.sub(right);
        if (moveRight) accel.add(right);
        if (accel.length() > 0) {
            // Use a higher multiplier when running.
            accel.normalize().multiplyScalar((isRunning ? 70 : 40) * transportationSpeed * delta);
        }
        return accel;
    }

    function onKeyDown(event) {
        const currentTime = performance.now();
        switch (event.code) {
        case "KeyW":
        case "ArrowUp":
            if (!moveForward && (currentTime - lastWPressTime < 300)) {
                isRunning = true;
            }
            lastWPressTime = currentTime;
            moveForward = true;
            Key["Forward"] = true;
            break;
        case "KeyS":
        case "ArrowDown":
            moveBackward = true;
            Key["Backward"] = true;
            break;
        case "KeyA":
        case "ArrowLeft":
            moveLeft = true;
            Key["Left"] = true;
            break;
        case "KeyD":
        case "ArrowRight":
            moveRight = true;
            Key["Right"] = true;
            break;
        case "Space":
            // Detect double tap on jump (threshold 300ms)
            if (currentTime - lastJumpTapTime < 300) {
                // Toggle flying mode only in normal mode
                if (gameMode === "normal") {
                    isFlying = !isFlying;
                    console.log("Flying: " + isFlying);
                }
                lastJumpTapTime = 0;
                flyUp = false;
                flyDown = false;
                break;
            } else {
                lastJumpTapTime = currentTime;
                if (gameMode === "normal") {
                    if (isFlying) {
                        flyUp = true;
                    } else if (canJump) {
                        velocity.y = jumpImpulse;
                        canJump = false;
                    }
                } else {
                    // In spectator mode, always fly upward on jump tap
                    flyUp = true;
                }
            }
            KEY["Jump"] = true;
            break;
        case "ShiftLeft":
        case "ShiftRight":
            if (gameMode === "normal" && isFlying) {
                flyDown = true;
            } else if (gameMode === "spectator") {
                flyDown = true;
            }
            break;
        case "KeyO":
            // Toggle game mode between normal and spectator
            if (gameMode === "normal") {
                gameMode = "spectator";
                isFlying = true; // always flying
                console.log("Game Mode: Spectator");
            } else {
                gameMode = "normal";
                isFlying = false; // revert to normal flying state
                console.log("Game Mode: Normal");
            }
            break;
        }
    }

    function onKeyUp(event) {
        switch (event.code) {
        case "KeyW":
        case "ArrowUp":
            moveForward = false;
            isRunning = false;
            break;
        case "KeyS":
        case "ArrowDown":
            moveBackward = false;
            break;
        case "KeyA":
        case "ArrowLeft":
            moveLeft = false;
            break;
        case "KeyD":
        case "ArrowRight":
            moveRight = false;
            break;
        case "Space":
            flyUp = false;
            break;
        case "ShiftLeft":
        case "ShiftRight":
            flyDown = false;
            break;
        }
    }

    // Block Interaction via Raycasting
    function onMouseDown(event) {
        // In spectator mode, disable interactions.
        if (gameMode === "spectator") return;
        pointer.set(0, 0);
        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(Object.values(loadedChunks));
        if (intersects.length > 0) {
        const intersect = intersects[0];
        if (event.button === 0) { // Left click: break block.
            const breakPos = new THREE.Vector3(
            Math.floor(intersect.point.x - intersect.face.normal.x * 0.01),
            Math.floor(intersect.point.y - intersect.face.normal.y * 0.01),
            Math.floor(intersect.point.z - intersect.face.normal.z * 0.01)
            );
            modifyBlockAt(breakPos, 0);
        } else if (event.button === 2) { // Right click: place block.
            const placePos = new THREE.Vector3(
            Math.floor(intersect.point.x + intersect.face.normal.x * 0.51),
            Math.floor(intersect.point.y + intersect.face.normal.y * 0.51),
            Math.floor(intersect.point.z + intersect.face.normal.z * 0.51)
            );
            modifyBlockAt(placePos, 2); // Place a dirt block by default.
            // You could modify this to allow players to select which material to place.
        }
        }
    }
    document.addEventListener("contextmenu", function (e) { e.preventDefault(); });

    // Animation, Physics & Collision Loop
    function animate() {
        requestAnimationFrame(animate);
        const time = performance.now();
        const delta = Math.min((time - prevTime) / 1000, 0.1);
        prevTime = time;
    
        if (controlsEnabled) {
            if (gameMode === "spectator") {
                // Always flying. Skip gravity and collision:
                velocity.x -= velocity.x * 10 * delta;
                velocity.z -= velocity.z * 10 * delta;
                const accel = getMovementAcceleration(delta);
                velocity.x += accel.x;
                velocity.z += accel.z;
                yawObject.position.x += velocity.x * delta;
                yawObject.position.z += velocity.z * delta;
                // Vertical movement via flyUp/flyDown (speed = 30 u/sec)
                if (flyUp) { yawObject.position.y += 30 * delta; }
                if (flyDown) { yawObject.position.y -= 30 * delta; }
            } else {
                if (!isFlying) {
                    velocity.x -= velocity.x * 10 * delta;
                    velocity.z -= velocity.z * 10 * delta;
                    velocity.y -= 9.8 * 5 * delta; // Gravity

                    const accel = getMovementAcceleration(delta);
                    velocity.x += accel.x;
                    velocity.z += accel.z;

                    yawObject.position.x += velocity.x * delta;
                    yawObject.position.z += velocity.z * delta;
                    resolveHorizontalCollisions();

                    const originalY = yawObject.position.y;
                    yawObject.position.y += velocity.y * delta;
                    if (collidesCylinder(yawObject.position.y, yawObject.position.x, yawObject.position.z)) {
                        if (velocity.y < 0) canJump = true;
                        yawObject.position.y = originalY;
                        velocity.y = 0;
                    }
                } else {
                    // Normal flying when toggled.
                    velocity.x -= velocity.x * 10 * delta;
                    velocity.z -= velocity.z * 10 * delta;
                    const accel = getMovementAcceleration(delta);
                    velocity.x += accel.x;
                    velocity.z += accel.z;
                    yawObject.position.x += velocity.x * delta;
                    yawObject.position.z += velocity.z * delta;
                    if (flyUp) { yawObject.position.y += 30 * delta; }
                    if (flyDown) { yawObject.position.y -= 30 * delta; }
                }
            }
            // Update chunks only when the player's chunk position changes
            let newChunkX = Math.floor(yawObject.position.x / CHUNK_SIZE);
            let newChunkZ = Math.floor(yawObject.position.z / CHUNK_SIZE);
            if (newChunkX !== lastPlayerChunkX || newChunkZ !== lastPlayerChunkZ) {
                updateChunks();
                lastPlayerChunkX = newChunkX;
                lastPlayerChunkZ = newChunkZ;
            }
        }
        
        // Process chunk loading queue
        processChunkQueue();
    
        // New underwater overlay update:
        const overlay = document.getElementById("underwater-overlay");
        // Check player's head position (using an offset relative to player height)
        const headY = Math.floor(yawObject.position.y + 0.8 * playerHeight);
        const blockAtHead = getBlockAt(Math.floor(yawObject.position.x), headY, Math.floor(yawObject.position.z));
        if (blockAtHead === BLOCK_TYPES.water) {
            overlay.style.display = "block";
        } else {
            overlay.style.display = "none";
        }

        // New water wavy camera effect:
        if (getBlockAt(Math.floor(yawObject.position.x), Math.floor(yawObject.position.y + 0.8 * playerHeight), Math.floor(yawObject.position.z)) === BLOCK_TYPES.water) {
            // Apply oscillation to cameraEffect rotation for a wavy effect
            cameraEffect.rotation.x = Math.sin(time * 0.005) * 0.02;
            cameraEffect.rotation.y = Math.cos(time * 0.005) * 0.02;
        } else {
            cameraEffect.rotation.set(0, 0, 0);
        }
    
        renderer.render(scene, camera);
    }

    init();
    </script>
</body>
</html>
