<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Wonder World (Alpha)</title>
    <style>
    body {
        margin: 0;
        overflow: hidden;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
    }
    #info {
        position: absolute;
        top: 0;
        width: 100%;
        color: #fff;
        font-family: sans-serif;
        padding: 10px;
        z-index: 1;
    }
    /* New underwater overlay styles */
    #underwater-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(51,102,255,0.5); /* blue transparent overlay */
        pointer-events: none;
        z-index: 999;
        display: none;
    }
    /* START: Loading Screen CSS */
    #loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0);
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: #fff;
        font-family: sans-serif;
        z-index: 10000;
    }
    #loading-progress-container {
        width: 70%;
        max-width: 400px;
        height: 20px;
        background: #333;
        border-radius: 10px;
        overflow: hidden;
        margin-bottom: 20px;
    }
    #loading-progress-bar {
        width: 0%;
        height: 100%;
        background: #4caf50;
        transition: width 0.3s;
    }
    #loading-text {
        font-size: 14px;
        text-align: center;
        padding: 0 20px;
        min-height: 20px;
    }
    /* END: Loading Screen CSS */

    /* START: Pause Screen CSS */
    #pause-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10001;
    }
    #pause-header {
        width: 100%;
        background: gray;
        padding: 20px;
        text-align: center;
    }
    #pause-header .title-1 {
        font-size: 48px;
        color: red;
        margin: 0;
    }
    #pause-header .title-2 {
        font-size: 48px;
        color: blue;
        margin: 0;
    }
    #pause-header .version {
        font-size: 20px;
        color: green;
        margin: 0;
    }
    #pause-buttons {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-top: 20px;
    }
    #pause-buttons button {
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
    }
    /* END: Pause Screen CSS */

    /* Loading Screen Styles */
    #loadingScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #fff;
      z-index: 9999;
    }
    #progressBar {
      width: 50%;
      height: 20px;
      background: #444;
      margin-top: 20px;
    }
    #progressBarInner {
      width: 0%;
      height: 100%;
      background: #0f0;
    }
    #loadingTip {
      margin-top: 10px;
      font-style: italic;
    }
    </style>
</head>
<body>
    <div id="info">
        Version: Alpha.8.3.6
    </div>
    <!-- New underwater overlay element -->
    <div id="underwater-overlay"></div>

    <!-- START: Loading Screen HTML -->
    <div id="loading-screen">
        <div id="loading-progress-container">
            <div id="loading-progress-bar"></div>
        </div>
        <div id="loading-text"></div>
    </div>
    <!-- END: Loading Screen HTML -->

    <!-- START: Pause Screen HTML -->
    <div id="pause-screen">
        <div id="pause-header">
            <h1 class="title-1">Wonder</h1>
            <h1 class="title-2">World</h1>
            <p class="version">Version Alpha.8.3.6</p>
        </div>
        <div id="pause-buttons">
            <button id="pause-resume">Resume</button>
            <button id="pause-settings">Settings</button>
            <button id="pause-save">Save World</button>
            <button id="pause-quit">Quit World</button>
        </div>
    </div>
    <!-- END: Pause Screen HTML -->



    <!-- Load Three.js from a CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- ImprovedNoise with Random Permutation -->
    <script>
    const none = null;

    const loadingText = [
        "You can fly by double-tapping the jump button.",
        "You will be able to toggle between game modes by pressing the 'O' key.",
        "You can now double-tap the 'W' key to run faster.",
        "What kind of builds will you create, today?",
        "In Wonder World Version Alpha.8.3.6, you can only place dirt.",
        "Did you know, most of Wonder World's code was written by AI? Don't worry, though, I (the developer) still carefully review and edit the code.",
        "<span style='font-size: 7px;'>If you can read this, you're sitting too close to the screen!</span>",  
        "We tried using quantum computing… but the qubits got lost in another dimension.",  
        "Pressing buttons does things. Some of them useful, some of them… interesting.",  
        "Running on pure imagination… and probably some spaghetti code.",  
        "Wonder World is made with magic, hope, and at least two gallons of coffee.",  
        "Tried to make the water wet. Turns out, it was already wet.",  
        "Every update adds something. What that something is… remains classified.",  
        "Achievement Unlocked: You found the loading screen!",  
        "Physics? Who needs physics in a game world?",  
        "Remember: If something is acting weird, it's not a bug. It's a feature.",  
        "Breaking news: Wonder World still doesn't have ray tracing. But hey, the sun works!",
    ]
    
    // Add a seeded random generator function:
    function seededRandomGenerator(seed) {
        var m = 0x80000000; // 2^31
        var a = 1103515245;
        var c = 12345;
        var g = 7499755 * seed / c;
        var u = c - seed * g;

        var state = seed ? seed : Math.floor(g * m % seed);

        return function() {
            state = (a * (state ) + c) % m;
            return state / (m - 1);
        };
    }
    // Replace your ImprovedNoise implementation with:
    var ImprovedNoise = function () {
        var seededRandom = seededRandomGenerator(worldSeed);
        var p = [];
        // Use a seeded random permutation
        for (var i = 0; i < 256; i++) {
            p[i] = Math.floor(seededRandom() * 256);
        }
        var permutation = new Array(512);
        for (var i = 0; i < 256; i++) {
            permutation[i] = p[i];
            permutation[i + 256] = p[i];
        }
        function fade(t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
        }
        function lerp(t, a, b) {
            return a + t * (b - a);
        }
        function grad(hash, x, y, z) {
            var h = hash & 15;
            var u = h < 8 ? x : y;
            var v = h < 4 ? y : (h === 12 || h === 14 ? x : z);
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }
        return {
            noise: function (x, y, z) {
                var floorX = Math.floor(x),
                    floorY = Math.floor(y),
                    floorZ = Math.floor(z);
                var X = floorX & 255,
                    Y = floorY & 255,
                    Z = floorZ & 255;
                x -= floorX;
                y -= floorY;
                z -= floorZ;
                var u = fade(x),
                    v = fade(y),
                    w = fade(z);
                var A = permutation[X] + Y,
                    AA = permutation[A] + Z,
                    AB = permutation[A + 1] + Z;
                var B = permutation[X + 1] + Y,
                    BA = permutation[B] + Z,
                    BB = permutation[B + 1] + Z;
                return lerp(
                    w,
                    lerp(
                        v,
                        lerp(u, grad(permutation[AA], x, y, z), grad(permutation[BA], x - 1, y, z)),
                        lerp(u, grad(permutation[AB], x, y - 1, z), grad(permutation[BB], x - 1, y - 1, z))
                    ),
                    lerp(
                        v,
                        lerp(u, grad(permutation[AA + 1], x, y, z - 1), grad(permutation[BA + 1], x - 1, y, z - 1)),
                        lerp(u, grad(permutation[AB + 1], x, y - 1, z - 1), grad(permutation[BB + 1], x - 1, y - 1, z - 1))
                    )
                );
            }
        };
    };
    </script>

    <!-- Main Game Script -->
    <script>
    /********************************************
     * World Data
     ********************************************/
    // Global World Constants & Variables
    const CHUNK_SIZE = 16;         // Blocks per side of a chunk
    const WORLD_HEIGHT = 216;        // Vertical blocks per chunk
    const WORLD_CHUNK_COUNT = 100;   // World chunk grid
    const VISIBLE_RADIUS = 12;        // Load chunks within a certain radius

    // The LOADING_REQUIREMENTS constant is used to define how the loading screen will behave.
    // "Local" means it only need to load and render chunks within the visible radius.
    // "Global" means it needs to preload all chunks in the world and render the local ones.
    const LOADING_REQUIREMENTS = "Local"; // NOT IMPLEMENTED YET

    // Load saved world data if available before chunk generation
    const loadSavedWorldPromise = (async function loadSavedWorld() {
        try {
            const response = await fetch('/savedWorlds/alphaWorld/world.json');
            if (response.ok) {
                const data = await response.json();
                chunkDataStore = data;
                console.log('Loaded saved world data.');
            } else {
                console.log('No saved world file found. Generating new world.');
            }
        } catch (err) {
            console.error('Error loading saved world:', err);
        }
    })();

    // START: Loading Screen Logic
    let isLoading = true;
    let forcePlay = false; // Force play to skip loading screen (for testing)
    const loadingScreenEl = document.getElementById('loading-screen');
    const loadingBarEl = document.getElementById('loading-progress-bar');
    const loadingTextEl = document.getElementById('loading-text');
    let loadedInitialChunksCount = 0;
    let loadingStartTime = Date.now();
    let minLoadingTime = 2000; // Minimum loading time in ms
    let hasStartedChunkLoading = false;
    
    // We'll use a dynamic loading approach - load a minimum number of chunks around the player
    let totalInitialChunksToLoad = Math.min(25, (2 * 3 + 1) ** 2); // Load at least 25 chunks or 7x7 area
    
    function showRandomLoadingText() {
        const idx = Math.floor(Math.random() * loadingText.length);
        loadingTextEl.innerHTML = loadingText[idx];
    }
    function updateLoadingBar() {
        const timePassed = Date.now() - loadingStartTime;
        const timeProgress = Math.min(timePassed / minLoadingTime, 1);
        const chunkProgress = Math.min(loadedInitialChunksCount / totalInitialChunksToLoad, 1);
        
        // Use the maximum of time-based and chunk-based progress
        const pct = Math.max(timeProgress, chunkProgress) * 100;
        loadingBarEl.style.width = pct + '%';
        
        // Complete loading if we have minimum chunks AND minimum time has passed
        if ((loadedInitialChunksCount >= Math.min(totalInitialChunksToLoad, 10) && timePassed >= minLoadingTime) || forcePlay) {
            loadingTextEl.innerHTML = "Loading complete!";
            clearInterval(loadingInterval);
            setTimeout(completeLoading, 500);
        }
    }
    // Called when each initial chunk finishes loading
    function chunkLoaded() {
        loadedInitialChunksCount++;
        updateLoadingBar();
    }
    function completeLoading() {
        loadingScreenEl.style.display = 'none';
        isLoading = false;
        // Prompt for pointer lock after user click
        document.addEventListener('click', function unlockPointer() {
          renderer.domElement.requestPointerLock();
          document.removeEventListener('click', unlockPointer);
        });
    }
    // Show loading screen and start text updates
    loadingScreenEl.style.display = 'flex';
    showRandomLoadingText();
    let loadingInterval = setInterval(showRandomLoadingText, 10000);
    updateLoadingBar();
    // END: Loading Screen Logic

    // Biome Data  
    /********************************************
     * Important Biome Data Notes:
     * 
     *   **TRANSITION** The transition value can be set to "None", "Mostly", or "Full"
     *   "None" means no transition between biomes. It may look a bit choppy for some biomes.
     *   "Mostly" means that the transition between biomes is mostly smooth. Some sections may look choppy while others are smooth.
     *   "Full" means that the transition between biomes is very smooth. Great for mountains and such.
     * 
     *   **LAYERS** The layers value is an array of objects. Each object has a type and number value.
     *   The layers are rendered from top to bottom till either the layer placing is complete, or reaches the very bottom of the chunk.
     *   If the layers are completed, the defaultLayer is used for the remaining blocks.
     * 
     *   The type is the block type. The number is the number of blocks of the type.
     *   The number can be a solid number made using an integer, or a string.
     *   There are three types of strings:
     *   Range "[min]-[max]": The number of blocks will be a random number between min and max.
     *   Single Number "[number]": The number of blocks will be number.
     *   Coordinates "$[yMin]-[yMax]": The number of blocks will be a random number between min and max.
     *********************************************/
    const BIOMES = {
        plains: {
            baseHeight: 55, // Base height for this biome
            heightVariation: 2, // Hill height
            frequency: 0.05, // Hill spread
            rarity: 80, // Frequency of biome (0-100)
            transition: "Full", // The rate of transition between neighboring biomes
            size: 0.5, // The size of the biome
            fill: none, // Fill the open area with the specified block under the number.
            defaultLayer: "stone", // Default block type for this biome
            layers: [
                { type: "dirt", number: "2-5" },
            ],
            structures: [
                { type: "tree", frequency: 0.5 },
                { type: "house", frequency: 0.01 }
            ]
        },
        hills: {
            baseHeight: 75, // Base height for this biome
            heightVariation: 8, // Hill height
            frequency: 0.05, // Hill spread
            rarity: 60, // Frequency of biome (0-100)
            transition: "Smooth", // The rate of transition between neighboring biomes
            size: 0.5, // The size of the biome
            fill: none, // Fill the open area with the specified block under the number.
            defaultLayer: "stone", // Default block type for this biome
            layers: [
                
            ],
            structures: [
                { type: "tree", frequency: 0.002 } // Reduced from 0.02 to 0.002 (0.2%)
            ]
        },
        ocean: {
            baseHeight: 15, // Base height for this biome
            heightVariation: 20, // Hill height
            frequency: 0.02, // Hill spread
            rarity: 60, // Frequency of biome (0-100)
            transition: "Smooth", // The rate of transition between neighboring biomes
            size: 0.8, // The size of the biome
            fill: { type: "water", height: 40 }, // Fill the open area with the specified block under the height.
            defaultLayer: "stone", // Default block type for this biome
            layers: [
                { type: "sand", number: "5-12" },
            ],
        }
    };

    // Add a mapping for block type strings
    const BLOCK_TYPES = {
        stone: 1,
        dirt: 2,
        wood: 3,
        leaves: 4,
        sand: 5,
        snow: 6,
        water: 7 // new water block type
    };

    // Structure Generators - Methods for generating different structures
    const StructureGenerators = {
        // Generate a tree at the given position
        tree: function(data, x, y, z) {
            const height = 4 + Math.floor(Math.random() * 3); // Tree height 4-6 blocks
            const leafRadius = 2;
            
            // Generate trunk
            for (let dy = 0; dy < height; dy++) {
                if (y + dy >= WORLD_HEIGHT) break;
                data[x][y + dy][z] = BLOCK_TYPES.wood;
            }
            
            // Generate leaves
            for (let dx = -leafRadius; dx <= leafRadius; dx++) {
                for (let dy = -1; dy <= 2; dy++) {
                    for (let dz = -leafRadius; dz <= leafRadius; dz++) {
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        if (dist <= leafRadius + 0.5) {
                            const lx = x + dx;
                            const ly = y + height - 1 + dy;
                            const lz = z + dz;
                            if (lx >= 0 && lx < CHUNK_SIZE && 
                                ly >= 0 && ly < WORLD_HEIGHT && 
                                lz >= 0 && lz < CHUNK_SIZE) {
                                if (data[lx][ly][lz] === 0) {
                                    data[lx][ly][lz] = BLOCK_TYPES.leaves;
                                }
                            }
                        }
                    }
                }
            }
        },
        
        // Generate a house at the given position
        house: function(data, x, y, z) {
            const width = 5;
            const length = 7;
            const height = 4;
            
            // Check if we have enough space in chunk
            if (x + width >= CHUNK_SIZE || z + length >= CHUNK_SIZE) return;
            if (y + height >= WORLD_HEIGHT) return;
            
            // Generate floor
            for (let dx = 0; dx < width; dx++) {
                for (let dz = 0; dz < length; dz++) {
                    data[x + dx][y][z + dz] = BLOCK_TYPES.stone;
                }
            }
            
            // Generate walls
            for (let dy = 1; dy < height; dy++) {
                for (let dx = 0; dx < width; dx++) {
                    for (let dz = 0; dz < length; dz++) {
                        // Skip if it's not a wall block
                        if (dx > 0 && dx < width - 1 && dz > 0 && dz < length - 1) continue;
                        data[x + dx][y + dy][z + dz] = BLOCK_TYPES.wood;
                    }
                }
            }
            
            // Generate roof
            for (let dx = 0; dx < width; dx++) {
                for (let dz = 0; dz < length; dz++) {
                    data[x + dx][y + height][z + dz] = BLOCK_TYPES.wood;
                }
            }
            
            // Add a door (2 blocks high)
            const doorX = x + Math.floor(width / 2);
            const doorZ = z;
            data[doorX][y + 1][doorZ] = 0;
            data[doorX][y + 2][doorZ] = 0;
            
            // Add windows
            const windowY = y + 2;
            // Front windows
            data[x + 1][windowY][z] = 0;
            data[x + width - 2][windowY][z] = 0;
            // Back windows
            data[x + 1][windowY][z + length - 1] = 0;
            data[x + width - 2][windowY][z + length - 1] = 0;
            // Side windows
            data[x][windowY][z + Math.floor(length / 2)] = 0;
            data[x + width - 1][windowY][z + Math.floor(length / 2)] = 0;
        }
    };

    // Updated blockColors to use block type names with Color and transparency properties.
    const blockColors = {
        stone: { color: "blocks/Stone.png", transparency: 1, sideRendering: "one" },
        dirt: { color: "blocks/Grass_Side.png", faces: {top: "blocks/Grass.png"}, transparency: 1, sideRendering: "one" },
        wood: { color: "blocks/Log_Side.png", faces: {top: "blocks/Log_Top.png", bottom: "blocks/Log_Top.png"}, transparency: 1, sideRendering: "one" },
        leaves: { color: new THREE.Color(0x88cc88), transparency: 1, sideRendering: "one" },
        sand: { color: "blocks/Sand.png", transparency: 1, sideRendering: "one" },
        snow: { color: new THREE.Color(0xffffff), transparency: 1, sideRendering: "one" },
        water: { color: "blocks/Water2.png", transparency: 0.7, sideRendering: "both", alphaTest: 0.1, seeThrough: true } // Updated water settings
    };

    // Texture support: preload textures for blocks that specify an image path in blockColors
    const textureLoader = new THREE.TextureLoader();
    textureLoader.crossOrigin = "anonymous";
    
    // Function to handle texture loading errors
    function onTextureLoadError(blockName, texturePath) {
        console.error(`Failed to load texture for ${blockName}: ${texturePath}`);
    }

    // Load textures for each block type
    Object.entries(blockColors).forEach(([name, props]) => {
        // Handle base texture
        if (typeof props.color === 'string') {
            try {
                props.texture = textureLoader.load(
                    props.color,
                    (texture) => {
                        // Enable transparency for the texture
                        texture.premultiplyAlpha = true;
                        texture.format = THREE.RGBAFormat;
                        // Store the block name in the texture's userData for later reference
                        texture.userData = { blockName: name };
                    },
                    undefined,
                    () => onTextureLoadError(name, props.color)
                );
                props.texture.wrapS = THREE.RepeatWrapping;
                props.texture.wrapT = THREE.RepeatWrapping;
                props.color = new THREE.Color(0xffffff);
            } catch (e) {
                console.error(`Error loading texture for ${name}:`, e);
                props.color = new THREE.Color(0xff00ff); // Fallback color
            }
        }
        
        // Handle per-face textures
        if (props.faces) {
            Object.entries(props.faces).forEach(([face, val]) => {
                if (typeof val === 'string') {
                    try {
                        const texture = textureLoader.load(
                            val,
                            (texture) => {
                                // Enable transparency for the texture
                                texture.premultiplyAlpha = true;
                                texture.format = THREE.RGBAFormat;
                                texture.userData = { blockName: name };
                            },
                            undefined,
                            () => onTextureLoadError(name, val)
                        );
                        texture.wrapS = THREE.RepeatWrapping;
                        texture.wrapT = THREE.RepeatWrapping;
                        props.faces[face] = {
                            texture: texture,
                            color: props.color || new THREE.Color(0xffffff)
                        };
                    } catch (e) {
                        console.error(`Error loading face texture for ${name}:`, e);
                        props.faces[face] = {
                            color: new THREE.Color(0xff00ff) // Fallback color
                        };
                    }
                }
            });
        }
    });

    // Helper to map BLOCK_TYPES number back to its name.
    function getBlockName(blockTypeNumber) {
        return Object.keys(BLOCK_TYPES).find(key => BLOCK_TYPES[key] === blockTypeNumber);
    }

    // Player collision and movement parameters.
    const playerHeight = 1.8;       
    const playerRadius = 0.3;       
    const jumpImpulse = 13; 
    const worldSeed = 10;        

    // Global variables for rendering, scene, and input.
    let scene, renderer;
    let camera, yawObject;
    let pitch = 0;
    let controlsEnabled = false;
    let velocity = new THREE.Vector3();
    let prevTime = performance.now();
    let moveForward = false,
        moveBackward = false,
        moveLeft = false,
        moveRight = false;
    let canJump = false;
    let lastPlayerChunkX = null, lastPlayerChunkZ = null;
    let loadedChunks = {};    // keys: "cx,cz" -> mesh
    let chunkDataStore = {};  // keys: "cx,cz" -> 3D block array
    
    // Add frustum for visibility checking
    const cameraFrustum = new THREE.Frustum();
    const cameraViewMatrix = new THREE.Matrix4();
    
    // Use a priority queue for chunk loading
    class PriorityQueue {
        constructor() {
            this.items = [];
        }
        
        enqueue(item, priority) {
            const queueItem = { item, priority };
            let contain = false;
            
            for (let i = 0; i < this.items.length; i++) {
                if (this.items[i].priority > priority) {
                    this.items.splice(i, 0, queueItem);
                    contain = true;
                    break;
                }
            }
            
            if (!contain) {
                this.items.push(queueItem);
            }
        }
        
        dequeue() {
            if (this.isEmpty()) return null;
            return this.items.shift().item;
        }
        
        isEmpty() {
            return this.items.length === 0;
        }
        
        clear() {
            this.items = [];
        }
        
        size() {
            return this.items.length;
        }
        
        contains(key) {
            return this.items.some(item => item.item.key === key);
        }
        
        // Prune chunks from the queue that no longer meet criteria
        prune(shouldKeepFn) {
            this.items = this.items.filter(queueItem => shouldKeepFn(queueItem.item));
        }
    }
    
    const chunkQueue = new PriorityQueue();

    // Noise generator and raycaster for block interactions.
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    // Global running detection.
    let lastWPressTime = 0;
    let isRunning = false;

    // Add global flying variables:
    let isFlying = false;
    let lastJumpTapTime = 0;
    let flyUp = false;
    let flyDown = false;

    // Add global game mode variable (default "normal")
    let gameMode = "normal"; // "normal" or "spectator"

    // FPS and game info tracking
    let fpsCounter = 0;
    let fpsLastTime = performance.now();
    let currentFPS = 0;
    let chunkUpdatesThisSecond = 0;
    let chunkUpdatesLastTime = performance.now();
    let showDebugInfo = true; // Toggle for debug info display

    // Function to update game info display
    function updateGameInfo() {
        const playerPos = yawObject.position;
        const chunksInMemory = Object.keys(chunkDataStore).length;
        const chunksLoaded = Object.keys(loadedChunks).length;
        const chunksInQueue = chunkQueue.size();
        const entities = 0; // Not implemented yet
        const chunksBeingProcessed = pendingChunks.size;
        
        // Format position to 2 decimal places
        const posX = playerPos.x.toFixed(2);
        const posY = playerPos.y.toFixed(2);
        const posZ = playerPos.z.toFixed(2);
        
        // Calculate chunk coordinates
        const chunkX = Math.floor(playerPos.x / CHUNK_SIZE);
        const chunkZ = Math.floor(playerPos.z / CHUNK_SIZE);
        
        // Create status indicators
        const statusIndicators = [];
        if (isFlying) statusIndicators.push('<span style="color: #ffff00;">Flying</span>');
        if (isInWater()) statusIndicators.push('<span style="color: #00ffff;">In Water</span>');
        if (isRunning) statusIndicators.push('<span style="color: #00ff00;">Running</span>');
        
        // Update info display
        const infoElement = document.getElementById('info');
        infoElement.innerHTML = `
            <div style="background: rgba(0,0,0,0.7); padding: 10px; border-radius: 6px; font-size: 11px; line-height: 1.5; font-family: 'Courier New', monospace; max-width: 280px;">
                <div style="font-size: 13px; font-weight: bold; margin-bottom: 8px; color: #ffffff;">Wonder World - Alpha.8.3.6</div>
                
                <div style="margin-bottom: 6px;">
                    <div style="color: #88ff88;">Performance:</div>
                    <div style="margin-left: 10px;">FPS: <span style="color: ${currentFPS >= 60 ? '#00ff00' : currentFPS >= 30 ? '#ffff00' : '#ff0000'}">${currentFPS}</span></div>
                </div>
                
                <div style="margin-bottom: 6px;">
                    <div style="color: #88ccff;">Chunks:</div>
                    <div style="margin-left: 10px;">
                        Memory: ${chunksInMemory}<br>
                        Loaded: ${chunksLoaded}<br>
                        Queue: ${chunksInQueue}<br>
                        Processing: ${chunksBeingProcessed}<br>
                        Updates/sec: ${chunkUpdatesThisSecond}
                    </div>
                </div>
                
                <div style="margin-bottom: 6px;">
                    <div style="color: #ffcc88;">Position:</div>
                    <div style="margin-left: 10px;">
                        World: ${posX}, ${posY}, ${posZ}<br>
                        Chunk: ${chunkX}, ${chunkZ}
                    </div>
                </div>
                
                <div style="margin-bottom: 6px;">
                    <div style="color: #ff88ff;">Game:</div>
                    <div style="margin-left: 10px;">
                        Mode: ${gameMode}<br>
                        Entities: ${entities}
                    </div>
                </div>
                
                ${statusIndicators.length > 0 ? `<div style="margin-top: 8px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.3);">${statusIndicators.join(' • ')}</div>` : ''}
            </div>
        `;
    }

    const KEY = {}

    // Remove pointer lock if any touch event occurs:
    document.addEventListener("touchstart", function(e) {
        if (document.pointerLockElement) {
            document.exitPointerLock();
        }
    }, { passive: true });

    // BEGIN new 8-button movement controls and jump button

    // Create container for left directional buttons
    const leftControlContainer = document.createElement("div");
    leftControlContainer.style.position = "absolute";
    leftControlContainer.style.left = "20px";
    leftControlContainer.style.bottom = "20px";
    leftControlContainer.style.width = "150px";
    leftControlContainer.style.height = "150px";
    document.body.appendChild(leftControlContainer);

    // Define the 8 directions with corresponding vectors and angles.
    const directions = [
        { name: "forward", vx: 0, vy: -1, angle: 90 },
        { name: "forwardRight", vx: 1, vy: -1, angle: 45 },
        { name: "right", vx: 1, vy: 0, angle: 0 },
        { name: "backRight", vx: 1, vy: 1, angle: 315 },
        { name: "back", vx: 0, vy: 1, angle: 270 },
        { name: "backLeft", vx: -1, vy: 1, angle: 225 },
        { name: "left", vx: -1, vy: 0, angle: 180 },
        { name: "forwardLeft", vx: -1, vy: -1, angle: 135 }
    ];
    directions.forEach(dir => {
        const btn = document.createElement("div");
        btn.id = "btn-" + dir.name;
        btn.innerHTML = dir.name;
        btn.style.position = "absolute";
        btn.style.width = "40px";
        btn.style.height = "40px";
        btn.style.background = "rgba(0,0,0,0.5)";
        btn.style.color = "#fff";
        btn.style.textAlign = "center";
        btn.style.lineHeight = "40px";
        btn.style.borderRadius = "50%";
        // Position buttons on a circle within the container
        const radius = 50;
        const centerX = 75;
        const centerY = 75;
        const rad = dir.angle * Math.PI/180;
        btn.style.left = (centerX + radius * Math.cos(rad) - 20) + "px";
        btn.style.top = (centerY - radius * Math.sin(rad) - 20) + "px";
        // On touchstart, set movement flags according to the direction.
        btn.addEventListener("touchstart", function(e) {
            e.preventDefault();
            moveForward = (dir.vy < 0);
            moveBackward = (dir.vy > 0);
            moveRight = (dir.vx > 0);
            moveLeft = (dir.vx < 0);
        }, false);
        btn.addEventListener("touchend", function(e) {
            e.preventDefault();
            moveForward = moveBackward = moveRight = moveLeft = false;
        }, false);
        leftControlContainer.appendChild(btn);
    });

    // Create jump button on the right side
    const jumpButton = document.createElement("div");
    jumpButton.style.position = "absolute";
    jumpButton.style.right = "20px";
    jumpButton.style.bottom = "20px";
    jumpButton.style.width = "80px";
    jumpButton.style.height = "80px";
    jumpButton.style.background = "rgba(0,0,0,0.5)";
    jumpButton.style.borderRadius = "50%";
    jumpButton.style.textAlign = "center";
    jumpButton.style.lineHeight = "80px";
    jumpButton.style.fontSize = "20px";
    jumpButton.innerHTML = "Jump";
    document.body.appendChild(jumpButton);
    jumpButton.addEventListener("touchstart", function(e) {
        e.preventDefault();
        if (canJump) {
            velocity.y = jumpImpulse;
            canJump = false;
        }
    }, false);

    // Global screen touch for camera control (excluding the two button areas)
    let cameraTouchStart = null;
    document.addEventListener("touchstart", function(e) {
        if (e.target !== leftControlContainer &&
            e.target !== jumpButton &&
            e.target.parentNode !== leftControlContainer) {
                cameraTouchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
    }, false);
    document.addEventListener("touchmove", function(e) {
        if (cameraTouchStart &&
            e.target !== leftControlContainer &&
            e.target !== jumpButton &&
            e.target.parentNode !== leftControlContainer) {
                let dx = e.touches[0].clientX - cameraTouchStart.x;
                let dy = e.touches[0].clientY - cameraTouchStart.y;
                yawObject.rotation.y -= dx * 0.005;
                pitch -= dy * 0.005;
                pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
                camera.rotation.x = pitch;
                cameraTouchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                e.preventDefault();
        }
    }, false);
    document.addEventListener("touchend", function(e) {
        cameraTouchStart = null;
    }, false);
    // END new touch button controls

    /********************************************
     * Methods
     ********************************************/
    // Cylinder-Based Collision Helpers
    function collidesCylinder(posY, posX, posZ) {
        const baseY = posY;
        const topY = posY + playerHeight;
        for (let bx = Math.floor(posX - playerRadius); bx <= Math.floor(posX + playerRadius); bx++) {
            for (let bz = Math.floor(posZ - playerRadius); bz <= Math.floor(posZ + playerRadius); bz++) {
                for (let by = Math.floor(baseY); by < Math.floor(topY) + 1; by++) {
                    // changed code: ignore water blocks
                    const block = getBlockAt(bx, by, bz);
                    if (block && block !== BLOCK_TYPES.water) {
                        if ((by < topY) && (by + 1 > baseY)) {
                            const nearestX = Math.max(bx, Math.min(posX, bx + 1));
                            const nearestZ = Math.max(bz, Math.min(posZ, bz + 1));
                            const dx = posX - nearestX;
                            const dz = posZ - nearestZ;
                            if (Math.sqrt(dx * dx + dz * dz) < playerRadius) return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    function resolveHorizontalCollisions() {
        let iterations = 0;
        while (iterations < 5) {
            let posX = yawObject.position.x;
            let posZ = yawObject.position.z;
            let correction = new THREE.Vector2(0, 0);
            let collided = false;
            const baseY = yawObject.position.y;
            const topY = baseY + playerHeight;
            for (let bx = Math.floor(posX - playerRadius); bx <= Math.floor(posX + playerRadius); bx++) {
                for (let bz = Math.floor(posZ - playerRadius); bz <= Math.floor(posZ + playerRadius); bz++) {
                    for (let by = Math.floor(baseY); by < Math.floor(topY) + 1; by++) {
                        // changed code: ignore water blocks
                        const block = getBlockAt(bx, by, bz);
                        if (block && block !== BLOCK_TYPES.water) {
                            if ((by < topY) && (by + 1 > baseY)) {
                                const nearestX = Math.max(bx, Math.min(posX, bx + 1));
                                const nearestZ = Math.max(bz, Math.min(posZ, bz + 1));
                                let dx = posX - nearestX;
                                let dz = posZ - nearestZ;
                                let dist = Math.sqrt(dx * dx + dz * dz);
                                if (dist < playerRadius) {
                                    let overlap = playerRadius - dist;
                                    if (dist === 0) {
                                        dx = 0.01;
                                        dz = 0.01;
                                        dist = Math.sqrt(dx * dx + dz * dz);
                                    }
                                    const nx = dx / dist;
                                    const nz = dz / dist;
                                    correction.x += nx * overlap;
                                    correction.y += nz * overlap;
                                    collided = true;
                                }
                            }
                        }
                    }
                }
            }
            if (collided) {
                yawObject.position.x += correction.x;
                yawObject.position.z += correction.y;
            } else {
                break;
            }
            iterations++;
        }
    }

    // Block & Chunk Helpers
    function getBlockAt(globalX, globalY, globalZ) {
        if (globalY < 0 || globalY >= WORLD_HEIGHT) return 0;
        const cx = Math.floor(globalX / CHUNK_SIZE);
        const cz = Math.floor(globalZ / CHUNK_SIZE);
        if (cx < 0 || cx >= WORLD_CHUNK_COUNT || cz < 0 || cz >= WORLD_CHUNK_COUNT) return 0;
        
        // Get block from chunk data
        const key = `${cx},${cz}`;
        const chunkData = chunkDataStore[key];
        if (!chunkData) {
            // For unloaded chunks, queue them for loading
            queueChunkLoad(cx, cz);
            return 0; // Return air for now
        }
        
        const localX = globalX - cx * CHUNK_SIZE;
        const localZ = globalZ - cz * CHUNK_SIZE;
        if (localX < 0 || localX >= CHUNK_SIZE || localZ < 0 || localZ >= CHUNK_SIZE) return 0;
        
        const block = chunkData[localX][globalY][localZ];
        return block;
    }

    // Helper function to check if player is in water
    function isInWater() {
        const pos = yawObject.position;
        const x = Math.floor(pos.x);
        const y = Math.floor(pos.y);
        const z = Math.floor(pos.z);
        
        // Check blocks at player's body (from feet to head)
        for (let dy = 0; dy <= Math.ceil(playerHeight); dy++) {
            if (getBlockAt(x, y + dy, z) === BLOCK_TYPES.water) {
                return true;
            }
        }
        return false;
    }

    function getBlockInChunk(chunkData, x, y, z) {
        if (y < 0 || y >= WORLD_HEIGHT) return 0;
        
        // Convert to global coordinates
        const globalX = chunkData.chunkX * CHUNK_SIZE + x;
        const globalZ = chunkData.chunkZ * CHUNK_SIZE + z;
        
        // Use getBlockAt for any coordinates - it will handle chunk boundaries
        return getBlockAt(globalX, y, globalZ);
    }

    const faces = [
        { // Left face (-X)
        dir: [-1, 0, 0],
        vertices: [
            [0, 0, 1],
            [0, 1, 1],
            [0, 1, 0],
            [0, 0, 0],
        ]
        },
        { // Right face (+X)
        dir: [1, 0, 0],
        vertices: [
            [1, 0, 0],
            [1, 1, 0],
            [1, 1, 1],
            [1, 0, 1],
        ]
        },
        { // Bottom face (-Y)
        dir: [0, -1, 0],
        vertices: [
            [0, 0, 0],
            [1, 0, 0],
            [1, 0, 1],
            [0, 0, 1],
        ]
        },
        { // Top face (+Y)
        dir: [0, 1, 0],
        vertices: [
            [0, 1, 1],
            [1, 1, 1],
            [1, 1, 0],
            [0, 1, 0],
        ]
        },
        { // Back face (-Z)
        dir: [0, 0, -1],
        vertices: [
            [1, 0, 0],
            [0, 0, 0],
            [0, 1, 0],
            [1, 1, 0],
        ]
        },
        { // Front face (+Z)
        dir: [0, 0, 1],
        vertices: [
            [0, 0, 1],
            [1, 0, 1],
            [1, 1, 1],
            [0, 1, 1],
        ]
        }
    ];
    // Add mapping from face index to face name for styling
    const faceNames = ["left", "right", "bottom", "top", "back", "front"];

    // Build Chunk Geometry with Vertex Colors
    function buildChunkGeometry(chunkData, cx, cz) {
        // Create separate arrays for each textured block type
        const texturedGeometries = {};
        const oVertices = [], oIndices = [], oUVs = [], oColors = [];
        let oVertexCount = 0;
        const tVertices = [], tIndices = [], tUVs = [], tColors = [];
        let tVertexCount = 0;

        // Helper function to check if a face should be culled
        function shouldCullFace(blockType, neighborType, isNeighborChunkLoaded) {
            // If the neighbor chunk isn't loaded, always cull that face
            if (!isNeighborChunkLoaded) return true;
            
            // If there's no neighbor block, don't cull
            if (!neighborType) return false;
            
            const blockName = getBlockName(blockType);
            const neighborName = getBlockName(neighborType);
            const blockProps = blockColors[blockName] || { transparency: 1 };
            const neighborProps = blockColors[neighborName] || { transparency: 1 };
            
            // If the neighbor is the same block type, always cull
            if (blockType === neighborType) return true;
            
            // If the neighbor is transparent or see-through, don't cull unless it's the same block type
            if (neighborProps.transparency < 1 || neighborProps.seeThrough) return false;
            
            // Otherwise, cull if there's a neighbor block
            return true;
        }

        for (let x = 0; x < CHUNK_SIZE; x++) {
            for (let y = 0; y < WORLD_HEIGHT; y++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    let blockType = chunkData[x][y][z];
                    if (blockType === 0) continue;
                    
                    const blockName = getBlockName(blockType);
                    const colObj = blockColors[blockName] || { color: new THREE.Color(0xffffff), transparency: 1 };

                    for (let f = 0; f < faces.length; f++) {
                        const face = faces[f];
                        const faceName = faceNames[f];
                        const nx = x + face.dir[0];
                        const ny = y + face.dir[1];
                        const nz = z + face.dir[2];
                        
                        // Get the actual global coordinates for proper neighbor checking
                        const globalX = cx * CHUNK_SIZE + x;
                        const globalZ = cz * CHUNK_SIZE + z;
                        
                        // Check neighbor block using global coordinates
                        let neighbor = 0; // Default to air if out of bounds
                        let isNeighborChunkLoaded = true;
                        
                        if (ny < 0 || ny >= WORLD_HEIGHT) {
                            // Y out of bounds - treat as air
                            neighbor = 0;
                        } else if (nx < 0 || nx >= CHUNK_SIZE || nz < 0 || nz >= CHUNK_SIZE) {
                            // At chunk boundary - use global coordinates
                            const neighborGlobalX = globalX + face.dir[0];
                            const neighborGlobalZ = globalZ + face.dir[2];
                            const neighborCx = Math.floor(neighborGlobalX / CHUNK_SIZE);
                            const neighborCz = Math.floor(neighborGlobalZ / CHUNK_SIZE);
                            
                            // Check if neighbor chunk exists
                            const neighborKey = `${neighborCx},${neighborCz}`;
                            if (chunkDataStore[neighborKey]) {
                                const neighborLocalX = ((neighborGlobalX % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                                const neighborLocalZ = ((neighborGlobalZ % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                                neighbor = chunkDataStore[neighborKey][neighborLocalX][ny][neighborLocalZ];
                            } else {
                                isNeighborChunkLoaded = false;
                            }
                        } else {
                            // Within same chunk and within bounds
                            neighbor = chunkData[nx][ny][nz];
                        }

                        // Check if this face should be culled
                        if (shouldCullFace(blockType, neighbor, isNeighborChunkLoaded)) {
                            continue;
                        }

                        // Get the texture for this face
                        let faceTexture = null;
                        if (colObj.faces && colObj.faces[faceName] && colObj.faces[faceName].texture) {
                            faceTexture = colObj.faces[faceName].texture;
                        } else if (colObj.texture) {
                            faceTexture = colObj.texture;
                        }

                        // If we have a texture, add to the appropriate textured geometry
                        if (faceTexture) {
                            // Create geometry arrays for this texture if they don't exist
                            const textureKey = blockName + (colObj.faces && colObj.faces[faceName] ? '_' + faceName : '');
                            if (!texturedGeometries[textureKey]) {
                                texturedGeometries[textureKey] = {
                                    vertices: [],
                                    indices: [],
                                    uvs: [],
                                    vertexCount: 0,
                                    texture: faceTexture
                                };
                            }

                            const geo = texturedGeometries[textureKey];
                            for (let i = 0; i < 4; i++) {
                                const v = face.vertices[i];
                                geo.vertices.push(
                                    cx * CHUNK_SIZE + x + v[0],
                                    y + v[1],
                                    cz * CHUNK_SIZE + z + v[2]
                                );
                            }
                            // Modify UV coordinates based on face
                            if (faceName === "left" || faceName === "right") {
                                // Rotate -90 degrees
                                geo.uvs.push(1, 0, 1, 1, 0, 1, 0, 0);
                            } else {
                                // Default UV mapping for other faces
                                geo.uvs.push(0, 0, 1, 0, 1, 1, 0, 1);
                            }
                            geo.indices.push(
                                geo.vertexCount, geo.vertexCount + 1, geo.vertexCount + 2,
                                geo.vertexCount, geo.vertexCount + 2, geo.vertexCount + 3
                            );
                            geo.vertexCount += 4;
                            continue;
                        }

                        // Handle non-textured faces
                        const baseColor = colObj.color instanceof THREE.Color ? colObj.color : new THREE.Color(0xffffff);
                        if (colObj.transparency === 1) {
                            for (let i = 0; i < 4; i++) {
                                const vertex = face.vertices[i];
                                oVertices.push(
                                    cx * CHUNK_SIZE + x + vertex[0],
                                    y + vertex[1],
                                    cz * CHUNK_SIZE + z + vertex[2]
                                );
                                oColors.push(baseColor.r, baseColor.g, baseColor.b);
                            }
                            oUVs.push(0, 0, 1, 0, 1, 1, 0, 1);
                            oIndices.push(
                                oVertexCount, oVertexCount + 1, oVertexCount + 2,
                                oVertexCount, oVertexCount + 2, oVertexCount + 3
                            );
                            oVertexCount += 4;
                        } else {
                            for (let i = 0; i < 4; i++) {
                                const vertex = face.vertices[i];
                                tVertices.push(
                                    cx * CHUNK_SIZE + x + vertex[0],
                                    y + vertex[1],
                                    cz * CHUNK_SIZE + z + vertex[2]
                                );
                                tColors.push(baseColor.r, baseColor.g, baseColor.b);
                            }
                            tUVs.push(0, 0, 1, 0, 1, 1, 0, 1);
                            tIndices.push(
                                tVertexCount, tVertexCount + 1, tVertexCount + 2,
                                tVertexCount, tVertexCount + 2, tVertexCount + 3
                            );
                            tVertexCount += 4;
                        }
                    }
                }
            }
        }

        // Create geometries
        let opaqueGeometry = null, transparentGeometry = null;
        const texturedMeshes = [];

        // Create opaque geometry
        if (oVertices.length) {
            opaqueGeometry = new THREE.BufferGeometry();
            opaqueGeometry.setAttribute("position", new THREE.Float32BufferAttribute(oVertices, 3));
            opaqueGeometry.setAttribute("uv", new THREE.Float32BufferAttribute(oUVs, 2));
            opaqueGeometry.setAttribute("color", new THREE.Float32BufferAttribute(oColors, 3));
            opaqueGeometry.setIndex(oIndices);
            opaqueGeometry.computeVertexNormals();
        }

        // Create transparent geometry
        if (tVertices.length) {
            transparentGeometry = new THREE.BufferGeometry();
            transparentGeometry.setAttribute("position", new THREE.Float32BufferAttribute(tVertices, 3));
            transparentGeometry.setAttribute("uv", new THREE.Float32BufferAttribute(tUVs, 2));
            transparentGeometry.setAttribute("color", new THREE.Float32BufferAttribute(tColors, 3));
            transparentGeometry.setIndex(tIndices);
            transparentGeometry.computeVertexNormals();
        }

        // Create textured geometries
        for (const [key, geo] of Object.entries(texturedGeometries)) {
            if (geo.vertices.length) {
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute("position", new THREE.Float32BufferAttribute(geo.vertices, 3));
                geometry.setAttribute("uv", new THREE.Float32BufferAttribute(geo.uvs, 2));
                geometry.setIndex(geo.indices);
                geometry.computeVertexNormals();
                texturedMeshes.push({
                    geometry: geometry,
                    texture: geo.texture
                });
            }
        }

        return { opaque: opaqueGeometry, transparent: transparentGeometry, textured: texturedMeshes };
    }

    // Chunk Management
    function loadChunk(cx, cz) {
        const key = `${cx},${cz}`;
        if (loadedChunks[key]) return;
        
        let chunkData = chunkDataStore[key];
        if (!chunkData) {
            // Queue chunk for generation by worker
            queueChunkLoad(cx, cz);
            
            // Also queue neighboring chunks to ensure proper face culling
            const neighbors = [
                [cx - 1, cz], [cx + 1, cz],
                [cx, cz - 1], [cx, cz + 1]
            ];
            
            for (const [ncx, ncz] of neighbors) {
                if (ncx >= 0 && ncx < WORLD_CHUNK_COUNT && 
                    ncz >= 0 && ncz < WORLD_CHUNK_COUNT) {
                    queueChunkLoad(ncx, ncz);
                }
            }
            return;
        }
        
        const geoms = buildChunkGeometry(chunkData, cx, cz);
        const group = new THREE.Group();
        
        // Add opaque meshes first
        if (geoms.opaque) {
            const opaqueMaterial = new THREE.MeshLambertMaterial({
                vertexColors: true,
                side: THREE.FrontSide,
                transparent: false
            });
            group.add(new THREE.Mesh(geoms.opaque, opaqueMaterial));
        }
        
        // Add textured meshes next, sorting by transparency
        for (const texturedMesh of geoms.textured) {
            const blockName = texturedMesh.texture.userData?.blockName;
            const blockProps = blockColors[blockName] || {};
            
            const material = new THREE.MeshLambertMaterial({
                map: texturedMesh.texture,
                transparent: true,
                side: blockProps.sideRendering === "both" ? THREE.DoubleSide : THREE.FrontSide,
                opacity: blockProps.transparency || 1,
                alphaTest: blockProps.alphaTest || 0.1,
                depthWrite: blockProps.transparency === 1 // Only write to depth buffer for fully opaque blocks
            });
            const mesh = new THREE.Mesh(texturedMesh.geometry, material);
            mesh.renderOrder = blockProps.transparency < 1 ? 1 : 0; // Render transparent blocks last
            group.add(mesh);
        }
        
        // Add transparent meshes last
        if (geoms.transparent) {
            const transparentMaterial = new THREE.MeshLambertMaterial({
                vertexColors: true,
                side: blockColors.water.sideRendering === "both" ? THREE.DoubleSide : THREE.FrontSide,
                transparent: true,
                depthWrite: false,
                opacity: blockColors.water.transparency
            });
            const mesh = new THREE.Mesh(geoms.transparent, transparentMaterial);
            mesh.renderOrder = 1; // Render after opaque objects
            group.add(mesh);
        }
        
        scene.add(group);
        loadedChunks[key] = group;
    }

    function unloadChunk(cx, cz) {
        const key = `${cx},${cz}`;
        if (loadedChunks[key]) {
            scene.remove(loadedChunks[key]);
            loadedChunks[key].traverse(obj => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });
            delete loadedChunks[key];
        }
    }

    function updateChunk(cx, cz) {
        const key = `${cx},${cz}`;
        if (!chunkDataStore[key]) return;
        
        // Track chunk updates
        chunkUpdatesThisSecond++;
        
        if (loadedChunks[key]) {
            scene.remove(loadedChunks[key]);
            loadedChunks[key].traverse(obj => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });
        }
        const geoms = buildChunkGeometry(chunkDataStore[key], cx, cz);
        const group = new THREE.Group();

        // Add opaque meshes first
        if (geoms.opaque) {
            const opaqueMaterial = new THREE.MeshLambertMaterial({
                vertexColors: true,
                side: THREE.FrontSide,
                transparent: false
            });
            const mesh = new THREE.Mesh(geoms.opaque, opaqueMaterial);
            mesh.renderOrder = 0;
            group.add(mesh);
        }

        // Add textured meshes next, sorting by transparency
        for (const texturedMesh of geoms.textured) {
            const blockName = texturedMesh.texture.userData?.blockName;
            const blockProps = blockColors[blockName] || {};
            
            const material = new THREE.MeshLambertMaterial({
                map: texturedMesh.texture,
                transparent: blockProps.transparency < 1,
                side: blockProps.sideRendering === "both" ? THREE.DoubleSide : THREE.FrontSide,
                opacity: blockProps.transparency || 1,
                alphaTest: blockProps.alphaTest || 0.1,
                depthWrite: blockProps.transparency === 1 // Only write to depth buffer for fully opaque blocks
            });
            const mesh = new THREE.Mesh(texturedMesh.geometry, material);
            mesh.renderOrder = blockProps.transparency < 1 ? 2 : 0; // Higher render order for transparent blocks
            group.add(mesh);
        }

        // Add transparent meshes last with highest render order
        if (geoms.transparent) {
            const transparentMaterial = new THREE.MeshLambertMaterial({
                vertexColors: true,
                side: blockColors.water.sideRendering === "both" ? THREE.DoubleSide : THREE.FrontSide,
                transparent: true,
                depthWrite: false,
                depthTest: true,
                opacity: blockColors.water.transparency,
                alphaTest: blockColors.water.alphaTest || 0.1
            });
            const mesh = new THREE.Mesh(geoms.transparent, transparentMaterial);
            mesh.renderOrder = 2; // Ensure water renders after other transparent objects
            group.add(mesh);
        }

        scene.add(group);
        loadedChunks[key] = group;
    }

    // Add chunk loading queue system
    const MAX_CHUNKS_PER_FRAME = 4; // Increased from 2 since we're using a worker now
    const chunkWorker = new Worker('chunkWorker.js');
    const pendingChunks = new Map(); // Track chunks being processed by worker

    // Helper function to strip texture data from block properties
    function getSerializableBlockProperties(blockColors) {
        const serializableProps = {};
        for (const [name, props] of Object.entries(blockColors)) {
            serializableProps[name] = {
                transparency: props.transparency || 1,
                seeThrough: props.seeThrough || false,
                sideRendering: props.sideRendering || "one"
            };
        }
        return serializableProps;
    }

    // Helper function to send chunk update to worker
    function sendChunkUpdate(cx, cz, chunkData) {
        chunkWorker.postMessage({
            type: "updateChunk",
            cx: cx,
            cz: cz,
            modifiedChunk: chunkData,
            constants: {
                blockColors: getSerializableBlockProperties(blockColors)
            }
        });
    }

    // Handle worker messages
    chunkWorker.onmessage = function(e) {
        const { cx, cz, geometryData, chunkData, type } = e.data;
        const key = `${cx},${cz}`;
        
        // Track chunk updates
        chunkUpdatesThisSecond++;
        
        // Fallback: if no geometryData but got chunkData, use legacy buildChunkGeometry
        if (!geometryData && chunkData) {
            // Store and render via existing methods
            chunkData.chunkX = cx;
            chunkData.chunkZ = cz;
            chunkDataStore[key] = chunkData;
            pendingChunks.delete(key);
            if (loadedChunks[key]) {
                updateChunk(cx, cz);
            } else {
                loadChunk(cx, cz);
            }
            if (isLoading) chunkLoaded();
            return;
        }

        // Remove from pending queue
        pendingChunks.delete(key);

        // If this is an update for an existing chunk, remove old mesh
        if (loadedChunks[key]) {
            scene.remove(loadedChunks[key]);
            loadedChunks[key].traverse(obj => { if (obj.geometry) obj.geometry.dispose(); if (obj.material) obj.material.dispose(); });
        }

        // Build new group from raw geometryData
        const group = new THREE.Group();

        // Opaque
        if (geometryData.opaque && geometryData.opaque.indices.length) {
            const buf = geometryData.opaque;
            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', new THREE.BufferAttribute(buf.vertices, 3));
            geom.setAttribute('uv', new THREE.BufferAttribute(buf.uvs, 2));
            geom.setAttribute('color', new THREE.BufferAttribute(buf.colors, 3));
            geom.setIndex(new THREE.BufferAttribute(buf.indices, 1));
            geom.computeVertexNormals();
            const mat = new THREE.MeshLambertMaterial({ vertexColors: true, side: THREE.FrontSide });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.renderOrder = 0;
            group.add(mesh);
        }

        // Textured
        if (geometryData.textured) {
            for (const entry of geometryData.textured) {
                const buf = entry;
                const geom = new THREE.BufferGeometry();
                geom.setAttribute('position', new THREE.BufferAttribute(buf.vertices, 3));
                geom.setAttribute('uv', new THREE.BufferAttribute(buf.uvs, 2));
                geom.setIndex(new THREE.BufferAttribute(buf.indices, 1));
                geom.computeVertexNormals();
                // Determine texture by key
                const [blockName, face] = entry.key.split('_');
                const texture = face && blockColors[blockName].faces && blockColors[blockName].faces[face]
                    ? blockColors[blockName].faces[face].texture
                    : blockColors[blockName].texture;
                const props = blockColors[blockName];
                const mat = new THREE.MeshLambertMaterial({
                    map: texture,
                    transparent: props.transparency < 1,
                    side: props.sideRendering === 'both' ? THREE.DoubleSide : THREE.FrontSide,
                    opacity: props.transparency,
                    alphaTest: props.alphaTest || 0.1,
                    depthWrite: props.transparency === 1
                });
                const mesh = new THREE.Mesh(geom, mat);
                mesh.renderOrder = props.transparency < 1 ? 2 : 0;
                group.add(mesh);
            }
        }

        // Transparent
        if (geometryData.transparent && geometryData.transparent.indices.length) {
            const buf = geometryData.transparent;
            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', new THREE.BufferAttribute(buf.vertices, 3));
            geom.setAttribute('uv', new THREE.BufferAttribute(buf.uvs, 2));
            geom.setAttribute('color', new THREE.BufferAttribute(buf.colors, 3));
            geom.setIndex(new THREE.BufferAttribute(buf.indices, 1));
            geom.computeVertexNormals();
            const props = blockColors.water;
            const mat = new THREE.MeshLambertMaterial({
                vertexColors: true,
                transparent: true,
                depthWrite: false,
                side: props.sideRendering === 'both' ? THREE.DoubleSide : THREE.FrontSide,
                opacity: props.transparency,
                alphaTest: props.alphaTest || 0.1
            });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.renderOrder = 2;
            group.add(mesh);
        }

        // Add to scene and track
        scene.add(group);
        loadedChunks[key] = group;

        if (isLoading) chunkLoaded();
    };
    
    function queueChunkLoad(cx, cz) {
        const key = `${cx},${cz}`;
        if (loadedChunks[key] || chunkQueue.contains(key) || pendingChunks.has(key)) return;
        
        // Calculate distance to player for priority
        const playerChunkX = Math.floor(yawObject.position.x / CHUNK_SIZE);
        const playerChunkZ = Math.floor(yawObject.position.z / CHUNK_SIZE);
        const distance = Math.sqrt(Math.pow(cx - playerChunkX, 2) + Math.pow(cz - playerChunkZ, 2));
        
        // Add to priority queue with distance as priority (lower distance = higher priority)
        chunkQueue.enqueue({ cx, cz, key }, distance);
    }
    
    function processChunkQueue() {
        const startTime = performance.now();
        const TIME_BUDGET = 16; // Try to keep chunk processing under 16ms per frame
        
        while (!chunkQueue.isEmpty() && 
               pendingChunks.size < MAX_CHUNKS_PER_FRAME && 
               performance.now() - startTime < TIME_BUDGET) {
            
            const { cx, cz, key } = chunkQueue.dequeue();
            
            // Skip if chunk is already loaded or being processed
            if (loadedChunks[key] || pendingChunks.has(key)) continue;
            
            // Mark chunk as pending
            pendingChunks.set(key, true);
            
            // Send chunk generation request to worker with block properties
            chunkWorker.postMessage({
                cx, 
                cz,
                constants: {
                    CHUNK_SIZE,
                    WORLD_HEIGHT,
                    BLOCK_TYPES,
                    BIOMES,
                    worldSeed,
                    blockColors: getSerializableBlockProperties(blockColors),
                    StructureGenerators: {
                        tree: StructureGenerators.tree.toString(),
                        house: StructureGenerators.house.toString()
                    }
                }
            });
        }
    }
    
    function updateChunks() {
        const playerPos = yawObject.position;
        let playerChunkX = Math.floor(playerPos.x / CHUNK_SIZE);
        let playerChunkZ = Math.floor(playerPos.z / CHUNK_SIZE);
        playerChunkX = Math.max(0, Math.min(WORLD_CHUNK_COUNT - 1, playerChunkX));
        playerChunkZ = Math.max(0, Math.min(WORLD_CHUNK_COUNT - 1, playerChunkZ));
        
        // Update camera frustum
        camera.updateMatrix();
        camera.updateMatrixWorld();
        cameraViewMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        cameraFrustum.setFromProjectionMatrix(cameraViewMatrix);
        
        // During loading, prioritize loading chunks around the player first
        if (isLoading && !hasStartedChunkLoading) {
            hasStartedChunkLoading = true;
            // Load a 5x5 grid around player first for initial loading
            for (let dx = -2; dx <= 2; dx++) {
                for (let dz = -2; dz <= 2; dz++) {
                    const cx = playerChunkX + dx;
                    const cz = playerChunkZ + dz;
                    if (cx >= 0 && cx < WORLD_CHUNK_COUNT && cz >= 0 && cz < WORLD_CHUNK_COUNT) {
                        queueChunkLoad(cx, cz);
                    }
                }
            }
        }
        
        // Calculate how far to check for chunks in view based on view frustum
        const loadDistance = isLoading ? 3 : VISIBLE_RADIUS + 1; // Smaller radius during loading
        
        // Clear previous queue if player moved to a new chunk
        if (lastPlayerChunkX !== playerChunkX || lastPlayerChunkZ !== playerChunkZ) {
            if (!isLoading) { // Only clear queue after loading is complete
                chunkQueue.clear();
            }
            lastPlayerChunkX = playerChunkX;
            lastPlayerChunkZ = playerChunkZ;
        }
        
        // Prune chunks from queue that are no longer in view or too far away (only after loading)
        if (!isLoading) {
            const beforeCount = chunkQueue.size();
            chunkQueue.prune(({ cx, cz }) => {
                // Distance check
                const dx = cx - playerChunkX;
                const dz = cz - playerChunkZ;
                const distance = Math.sqrt(dx*dx + dz*dz);
                
                // Always keep very close chunks
                if (distance <= 2) return true;
                
                // For farther chunks, check if they're still in view
                if (distance > loadDistance) return false;
                
                // Create chunk bounds for frustum checking
                const chunkMin = new THREE.Vector3(cx * CHUNK_SIZE, 0, cz * CHUNK_SIZE);
                const chunkMax = new THREE.Vector3((cx + 1) * CHUNK_SIZE, WORLD_HEIGHT, (cz + 1) * CHUNK_SIZE);
                const chunkBox = new THREE.Box3(chunkMin, chunkMax);
                
                // Keep if in frustum or close enough
                return cameraFrustum.intersectsBox(chunkBox);
            });
            const afterCount = chunkQueue.size();
            if (beforeCount !== afterCount) {
                console.log(`Pruned ${beforeCount - afterCount} chunks from queue (${beforeCount} -> ${afterCount})`);
            }
        }

        // Check chunks in view frustum and prioritize by distance
        for (let dx = -loadDistance; dx <= loadDistance; dx++) {
            for (let dz = -loadDistance; dz <= loadDistance; dz++) {
                const cx = playerChunkX + dx;
                const cz = playerChunkZ + dz;
                
                if (cx < 0 || cx >= WORLD_CHUNK_COUNT || cz < 0 || cz >= WORLD_CHUNK_COUNT) {
                    continue;
                }
                
                // During loading, load all chunks in the smaller radius
                if (isLoading) {
                    queueChunkLoad(cx, cz);
                    continue;
                }
                
                // Calculate chunk center position to check against frustum
                const chunkCenterX = (cx + 0.5) * CHUNK_SIZE;
                const chunkCenterY = WORLD_HEIGHT / 2;
                const chunkCenterZ = (cz + 0.5) * CHUNK_SIZE;
                
                // Create chunk bounds for frustum checking
                const chunkMin = new THREE.Vector3(
                    cx * CHUNK_SIZE, 
                    0, 
                    cz * CHUNK_SIZE
                );
                
                const chunkMax = new THREE.Vector3(
                    (cx + 1) * CHUNK_SIZE, 
                    WORLD_HEIGHT, 
                    (cz + 1) * CHUNK_SIZE
                );
                
                // Create bounding box for the chunk
                const chunkBox = new THREE.Box3(chunkMin, chunkMax);
                
                // If chunk is in view frustum or very close to player, queue it
                const distanceToPlayer = Math.sqrt(dx*dx + dz*dz);
                
                if (distanceToPlayer <= 2 || cameraFrustum.intersectsBox(chunkBox)) {
                    queueChunkLoad(cx, cz);
                }
            }
        }

        // Unload chunks that are too far or not in view (only after loading is complete)
        if (!isLoading) {
            for (const key in loadedChunks) {
                const [cx, cz] = key.split(",").map(Number);
                
                // Distance-based culling
                const dx = cx - playerChunkX;
                const dz = cz - playerChunkZ;
                const distance = Math.sqrt(dx*dx + dz*dz);
                
                // Create chunk bounds for frustum checking
                const chunkMin = new THREE.Vector3(cx * CHUNK_SIZE, 0, cz * CHUNK_SIZE);
                const chunkMax = new THREE.Vector3((cx + 1) * CHUNK_SIZE, WORLD_HEIGHT, (cz + 1) * CHUNK_SIZE);
                const chunkBox = new THREE.Box3(chunkMin, chunkMax);
                
                // Check if chunk is out of range or not in view frustum
                const inFrustum = cameraFrustum.intersectsBox(chunkBox);
                
                if (distance > VISIBLE_RADIUS + 1 || (!inFrustum && distance > 2)) {
                    unloadChunk(cx, cz);
                }
            }
        }
    }
    
    // Block Modification (Place / Break)
    function modifyBlockAt(worldPos, value) {
        // In spectator mode, disable interactions.
        if (gameMode === "spectator") return;
        
        const gx = Math.floor(worldPos.x);
        const gy = Math.floor(worldPos.y);
        const gz = Math.floor(worldPos.z);
        const cx = Math.floor(gx / CHUNK_SIZE);
        const cz = Math.floor(gz / CHUNK_SIZE);
        const key = `${cx},${cz}`;
        
        if (!chunkDataStore[key]) {
            console.log("Chunk not loaded. Cannot modify block.");
            return;
        }
        
        const localX = gx - cx * CHUNK_SIZE;
        const localZ = gz - cz * CHUNK_SIZE;
        
        if (gy < 0 || gy >= WORLD_HEIGHT) {
            console.log("Block coordinates out of range.");
            return;
        }
        
        // Modify the block
        chunkDataStore[key][localX][gy][localZ] = value;
        
        // Send update to worker and wait for response before updating visuals
        sendChunkUpdate(cx, cz, chunkDataStore[key]);

        // Update affected chunks
        const chunksToUpdate = new Set();
        chunksToUpdate.add(key);
        
        // Add neighboring chunks if we're on a boundary
        if (localX === 0 && cx > 0) chunksToUpdate.add(`${cx-1},${cz}`);
        if (localX === CHUNK_SIZE - 1 && cx < WORLD_CHUNK_COUNT - 1) chunksToUpdate.add(`${cx+1},${cz}`);
        if (localZ === 0 && cz > 0) chunksToUpdate.add(`${cx},${cz-1}`);
        if (localZ === CHUNK_SIZE - 1 && cz < WORLD_CHUNK_COUNT - 1) chunksToUpdate.add(`${cx},${cz+1}`);

        // Update all affected chunks
        for (const chunkKey of chunksToUpdate) {
            const [updateCx, updateCz] = chunkKey.split(',').map(Number);
            if (chunkDataStore[chunkKey]) {
                updateChunk(updateCx, updateCz);
            }
        }
    }

    // Initialization & Rendering & Input Handling
    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x88ccff);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 0.5);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -8;
        directionalLight.shadow.camera.right = 8;
        directionalLight.shadow.camera.top = 8;
        directionalLight.shadow.camera.bottom = -8;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        scene.add(directionalLight);

        // Set up camera and first-person hierarchy.
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Position the camera at 80% of the cylinder height (simulating the head).
        camera.position.set(0, 0.8 * playerHeight, 0);
        yawObject = new THREE.Object3D();
        
        // Place the player near the center of the world
        let startX = (WORLD_CHUNK_COUNT * CHUNK_SIZE) / 2;
        let startZ = (WORLD_CHUNK_COUNT * CHUNK_SIZE) / 2;
        let startY = 100; // Start high up and let gravity bring us down
        yawObject.position.set(startX, startY, startZ);

        // Remove direct addition of camera and add it to a new holder for water effect
        cameraEffect = new THREE.Object3D();
        cameraEffect.add(camera);
        yawObject.add(cameraEffect);
        scene.add(yawObject);
        
        // Preload visible chunks so the world is ready.
        updateChunks();
        
        // Setup Pointer Lock.
        const element = document.body;
        document.addEventListener("pointerlockchange", onPointerLockChange, false);
        document.addEventListener("pointerlockerror", onPointerLockError, false);
        document.addEventListener("mousemove", onMouseMove, false);
        document.addEventListener("mousedown", onMouseDown, false);
        window.addEventListener("keydown", onKeyDown, false);
        window.addEventListener("keyup", onKeyUp, false);
        window.addEventListener("resize", onWindowResize, false);

        animate();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onPointerLockChange() {
        controlsEnabled = !isLoading && (document.pointerLockElement === document.body);
        // Show or hide pause screen when unlocked
        const pauseEl = document.getElementById('pause-screen');
        if (!controlsEnabled && !isLoading) {
            pauseEl.style.display = 'flex';
        } else {
            pauseEl.style.display = 'none';
        }
    }
    function onPointerLockError() {
        console.error("PointerLock Error");
    }
    function onMouseMove(event) {
        if (!controlsEnabled) return;
        const movementX = event.movementX || 0;
        const movementY = event.movementY || 0;
        yawObject.rotation.y -= movementX * 0.002;
        pitch -= movementY * 0.002;
        pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
        camera.rotation.x = pitch;
    }

    function getMovementAcceleration(delta) {
        var transportationSpeed = 1;
        if (isFlying) {
            transportationSpeed = 2;
        }
        const forward = new THREE.Vector3(0, 0, -1)
        .applyAxisAngle(new THREE.Vector3(0, 1, 0), yawObject.rotation.y);
        const right = new THREE.Vector3(1, 0, 0)
        .applyAxisAngle(new THREE.Vector3(0, 1, 0), yawObject.rotation.y);
        const accel = new THREE.Vector3();
        if (moveForward) accel.add(forward);
        if (moveBackward) accel.sub(forward);
        if (moveLeft) accel.sub(right);
        if (moveRight) accel.add(right);
        if (accel.length() > 0) {
            // Use a higher multiplier when running.
            accel.normalize().multiplyScalar((isRunning ? 70 : 40) * transportationSpeed * delta);
        }
        return accel;
    }

    function onKeyDown(event) {
        const currentTime = performance.now();
        switch (event.code) {
        case "KeyW":
        case "ArrowUp":
            if (!moveForward && (currentTime - lastWPressTime < 300)) {
                isRunning = true;
            }
            lastWPressTime = currentTime;
            moveForward = true;
            KEY["Forward"] = true;
            break;
        case "KeyS":
        case "ArrowDown":
            moveBackward = true;
            KEY["Backward"] = true;
            break;
        case "KeyA":
        case "ArrowLeft":
            moveLeft = true;
            KEY["Left"] = true;
            break;
        case "KeyD":
        case "ArrowRight":
            moveRight = true;
            KEY["Right"] = true;
            break;
        case "Space":
            // Detect double tap on jump (threshold 300ms)
            if (currentTime - lastJumpTapTime < 300) {
                // Toggle flying mode only in normal mode and when not in water
                if (gameMode === "normal" && !isInWater()) {
                    isFlying = !isFlying;
                    console.log("Flying: " + isFlying);
                }
                lastJumpTapTime = 0;
                flyUp = false;
                flyDown = false;
                break;
            } else {
                lastJumpTapTime = currentTime;
                if (gameMode === "normal") {
                    if (isFlying) {
                        flyUp = true;
                    } else if (canJump) {
                        velocity.y = jumpImpulse;
                        canJump = false;
                    }
                } else {
                    // In spectator mode, always fly upward on jump tap
                    flyUp = true;
                }
            }
            KEY["Jump"] = true;
            break;
        case "ShiftLeft":
        case "ShiftRight":
            if (gameMode === "normal" && isFlying) {
                flyDown = true;
            } else if (gameMode === "spectator") {
                flyDown = true;
            }
            break;
        case "KeyO":
            // Toggle game mode between normal and spectator
            if (gameMode === "normal") {
                gameMode = "spectator";
                isFlying = true; // always flying
                console.log("Game Mode: Spectator");
            } else {
                gameMode = "normal";
                isFlying = false; // revert to normal flying state
                console.log("Game Mode: Normal");
            }
            break;
        case "F3":
            // Toggle debug info display
            event.preventDefault(); // Prevent browser dev tools
            showDebugInfo = !showDebugInfo;
            console.log("Debug Info: " + (showDebugInfo ? "On" : "Off"));
            break;
        }
    }

    function onKeyUp(event) {
        switch (event.code) {
        case "KeyW":
        case "ArrowUp":
            moveForward = false;
            isRunning = false;
            break;
        case "KeyS":
        case "ArrowDown":
            moveBackward = false;
            break;
        case "KeyA":
        case "ArrowLeft":
            moveLeft = false;
            break;
        case "KeyD":
        case "ArrowRight":
            moveRight = false;
            break;
        case "Space":
            flyUp = false;
            break;
        case "ShiftLeft":
        case "ShiftRight":
            flyDown = false;
            break;
        }
    }

    // Block Interaction via Raycasting
    function onMouseDown(event) {
        // In spectator mode, disable interactions.
        if (gameMode === "spectator") return;
        // Disable mining/placing when pointer lock not active
        if (!controlsEnabled) return;
        // Set pointer coordinates: use screen coords when unlocked, center when locked
        if (document.pointerLockElement === document.body) {
            pointer.set(0, 0);
        } else {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }
        raycaster.setFromCamera(pointer, camera);
        // Include all meshes in nested groups
        const intersects = raycaster.intersectObjects(Object.values(loadedChunks), true);
        if (intersects.length >  0) {
        const intersect = intersects[0];
        if (event.button === 0) { // Left click: break block.
            const breakPos = new THREE.Vector3(
            Math.floor(intersect.point.x - intersect.face.normal.x * 0.01),
            Math.floor(intersect.point.y - intersect.face.normal.y * 0.01),
            Math.floor(intersect.point.z - intersect.face.normal.z * 0.01)
            );
            modifyBlockAt(breakPos, 0);
        } else if (event.button === 2) { // Right click: place block.
            const placePos = new THREE.Vector3(
            Math.floor(intersect.point.x + intersect.face.normal.x * 0.51),
            Math.floor(intersect.point.y + intersect.face.normal.y * 0.51),
            Math.floor(intersect.point.z + intersect.face.normal.z * 0.51)
            );
            modifyBlockAt(placePos, 2); // Place a dirt block by default.
            // You could modify this to allow players to select which material to place.
        }
        }
    }
    document.addEventListener("contextmenu", function (e) { e.preventDefault(); });

    // Animation, Physics & Collision Loop
    function animate() {
        requestAnimationFrame(animate);
        const time = performance.now();
        const delta = Math.min((time - prevTime) / 1000, 0.1);
        prevTime = time;

        // Calculate FPS
        fpsCounter++;
        if (time - fpsLastTime >= 1000) {
            currentFPS = Math.round((fpsCounter * 1000) / (time - fpsLastTime));
            fpsCounter = 0;
            fpsLastTime = time;
            
            // Reset chunk updates counter
            chunkUpdatesThisSecond = 0;
            chunkUpdatesLastTime = time;
        }

        // Update game info display every frame
        if (!isLoading && showDebugInfo) {
            updateGameInfo();
        } else if (!showDebugInfo) {
            // Hide debug info but keep version
            const infoElement = document.getElementById('info');
            infoElement.innerHTML = `
                <div style="background: rgba(0,0,0,0.7); padding: 8px; border-radius: 6px; font-size: 11px; font-family: 'Courier New', monospace;">
                    <div style="font-size: 13px; font-weight: bold; color: #ffffff;">Wonder World - Alpha.8.3.6</div>
                    <div style="margin-top: 4px; font-size: 10px; color: #cccccc;">Press F3 to toggle debug info</div>
                </div>
            `;
        }
    
        if (controlsEnabled) {
            if (gameMode === "spectator") {
                // Always flying. Skip gravity and collision:
                velocity.x -= velocity.x * 10 * delta;
                velocity.z -= velocity.z * 10 * delta;
                const accel = getMovementAcceleration(delta);
                velocity.x += accel.x;
                velocity.z += accel.z;
                yawObject.position.x += velocity.x * delta;
                yawObject.position.z += velocity.z * delta;
                // Vertical movement via flyUp/flyDown (speed = 30 u/sec)
                if (flyUp) { yawObject.position.y += 30 * delta; }
                if (flyDown) { yawObject.position.y -= 30 * delta; }
            } else {
                if (!isFlying) {
                    const inWater = isInWater();
                    
                    // Water physics
                    if (inWater) {
                        // Slower movement in water (5/2 times slower)
                        const waterMovementFactor = 0.4; // 1 / (5/2)
                        
                        // Reduced gravity and fall speed in water
                        const waterGravity = 9.8 * 1.5; // Reduced gravity
                        const waterDrag = 0.8; // Water resistance
                        
                        // Apply water physics
                        velocity.x -= velocity.x * 3 * delta; // More drag in water
                        velocity.z -= velocity.z * 3 * delta;
                        
                        // Gradually slow down if falling too fast
                        if (velocity.y < -waterGravity) {
                            velocity.y = THREE.MathUtils.lerp(velocity.y, -waterGravity, delta * 3);
                        } else {
                            velocity.y -= waterGravity * delta;
                        }
                        
                        // Handle vertical movement in water
                        if (KEY["Jump"]) {
                            // Float up when holding jump
                            velocity.y = Math.min(velocity.y + 20 * delta, 8);
                        } else {
                            // Slowly sink when not holding jump
                            velocity.y = Math.max(velocity.y - 10 * delta, -4);
                        }
                        
                        // Apply movement with water resistance
                        const accel = getMovementAcceleration(delta);
                        velocity.x += accel.x * waterMovementFactor;
                        velocity.z += accel.z * waterMovementFactor;
                        
                        // Apply water drag
                        velocity.multiplyScalar(waterDrag);
                        
                    } else {
                        // Normal physics
                        velocity.x -= velocity.x * 10 * delta;
                        velocity.z -= velocity.z * 10 * delta;
                        velocity.y -= 9.8 * 5 * delta; // Gravity
                        
                        const accel = getMovementAcceleration(delta);
                        velocity.x += accel.x;
                        velocity.z += accel.z;
                    }

                    yawObject.position.x += velocity.x * delta;
                    yawObject.position.z += velocity.z * delta;
                    resolveHorizontalCollisions();

                    const originalY = yawObject.position.y;
                    yawObject.position.y += velocity.y * delta;
                    if (collidesCylinder(yawObject.position.y, yawObject.position.x, yawObject.position.z)) {
                        if (velocity.y < 0) canJump = true;
                        yawObject.position.y = originalY;
                        velocity.y = 0;
                    }
                } else {
                    // Normal flying when toggled.
                    velocity.x -= velocity.x * 10 * delta;
                    velocity.z -= velocity.z * 10 * delta;
                    const accel = getMovementAcceleration(delta);
                    velocity.x += accel.x;
                    velocity.z += accel.z;
                    yawObject.position.x += velocity.x * delta;
                    yawObject.position.z += velocity.z * delta;
                    if (flyUp) { yawObject.position.y += 30 * delta; }
                    if (flyDown) { yawObject.position.y -= 30 * delta; }
                }
            }
            // Update chunks only when the player's chunk position changes
            let newChunkX = Math.floor(yawObject.position.x / CHUNK_SIZE);
            let newChunkZ = Math.floor(yawObject.position.z / CHUNK_SIZE);
            if (newChunkX !== lastPlayerChunkX || newChunkZ !== lastPlayerChunkZ) {
                updateChunks();
                lastPlayerChunkX = newChunkX;
                lastPlayerChunkZ = newChunkZ;
            }
        }
        
        // Process chunk loading queue
        processChunkQueue();
    
        // New underwater overlay update:
        const overlay = document.getElementById("underwater-overlay");
        // Check player's head position (using an offset relative to player height)
        const headY = Math.floor(yawObject.position.y + 0.8 * playerHeight);
        const blockAtHead = getBlockAt(Math.floor(yawObject.position.x), headY, Math.floor(yawObject.position.z));
        if (blockAtHead === BLOCK_TYPES.water) {
            overlay.style.display = "block";
        } else {
            overlay.style.display = "none";
        }

        // New water wavy camera effect:
        if (getBlockAt(Math.floor(yawObject.position.x), Math.floor(yawObject.position.y + 0.8 * playerHeight), Math.floor(yawObject.position.z)) === BLOCK_TYPES.water) {
            // Apply oscillation to cameraEffect rotation for a wavy effect
            cameraEffect.rotation.x = Math.sin(time * 0.005) * 0.02;
            cameraEffect.rotation.y = Math.cos(time * 0.005) * 0.02;
        } else {
            cameraEffect.rotation.set(0, 0, 0);
        }
    
        renderer.render(scene, camera);
    }

    // Setup Pause Screen Button Handlers
    const resumeBtn = document.getElementById('pause-resume');
    const settingsBtn = document.getElementById('pause-settings');
    const saveBtn = document.getElementById('pause-save');
    const quitBtn = document.getElementById('pause-quit');
    resumeBtn.addEventListener('click', () => {
        document.body.requestPointerLock();
    });
    // Replace Settings placeholder with FOV prompt
    settingsBtn.addEventListener('click', () => {
        const currentFov = camera.fov;
        const input = prompt('Set Field of View (FOV) between 10 and 150:', currentFov);
        const newFov = parseFloat(input);
        if (!isNaN(newFov) && newFov > 10 && newFov < 150) {
            camera.fov = newFov;
            camera.updateProjectionMatrix();
       
        } else if (input !== null) {
            alert('Invalid FOV value. Please enter a number between 10 and 150.');
        }
    });
    saveBtn.addEventListener('click', () => {
        // Placeholder for save functionality
        alert('Save feature is not implemented yet.');
    });
    quitBtn.addEventListener('click', () => {
               // Placeholder for quit functionality
        alert('Quit feature is not implemented yet.');
    });

    // Wait for saved world load before initialization and chunk generation
    loadSavedWorldPromise.then(() => {
        init();
    });
    </script>
</body>
</html>
