<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Wonder World (Alpha)</title>
    <style>
    body {
        margin: 0;
        overflow: hidden;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
    }
    #info {
        position: absolute;
        top: 0;
        width: 100%;
        color: #fff;
        font-family: sans-serif;
        padding: 10px;
        z-index: 1;
    }
    /* New underwater overlay styles */
    #underwater-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(51,102,255,0.5); /* blue transparent overlay */
        pointer-events: none;
        z-index: 999;
        display: none;
    }
    /* START: Loading Screen CSS */
    #loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0);
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: #fff;
        font-family: sans-serif;
        z-index: 10000;
    }
    #loading-progress-container {
        width: 70%;
        max-width: 400px;
        height: 20px;
        background: #333;
        border-radius: 10px;
        overflow: hidden;
        margin-bottom: 20px;
    }
    #loading-progress-bar {
        width: 0%;
        height: 100%;
        background: #4caf50;
        transition: width 0.3s;
    }
    #loading-text {
        font-size: 14px;
        text-align: center;
        padding: 0 20px;
        min-height: 20px;
    }
    /* END: Loading Screen CSS */

    /* START: Pause Screen CSS */
    #pause-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10001;
    }
    #pause-header {
        width: 100%;
        background: gray;
        padding: 20px;
        text-align: center;
    }
    #pause-header .title-1 {
        font-size: 48px;
        color: red;
        margin: 0;
    }
    #pause-header .title-2 {
        font-size: 48px;
        color: blue;
        margin: 0;
    }
    #pause-header .version {
        font-size: 20px;
        color: green;
        margin: 0;
    }
    #pause-buttons {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-top: 20px;
    }
    #pause-buttons button {
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
    }
    /* END: Pause Screen CSS */

    /* Loading Screen Styles */
    #loadingScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #fff;
      z-index: 9999;
    }
    #progressBar {
      width: 50%;
      height: 20px;
      background: #444;
      margin-top: 20px;
    }
    #progressBarInner {
      width: 0%;
      height: 100%;
      background: #0f0;
    }
    #loadingTip {
      margin-top: 10px;
      font-style: italic;
    }
    </style>
</head>
<body>
    <div id="info">
        Version: Alpha.8.3.6
    </div>
    <!-- New underwater overlay element -->
    <div id="underwater-overlay"></div>

    <!-- START: Loading Screen HTML -->
    <div id="loading-screen">
        <div id="loading-progress-container">
            <div id="loading-progress-bar"></div>
        </div>
        <div id="loading-text"></div>
    </div>
    <!-- END: Loading Screen HTML -->

    <!-- START: Pause Screen HTML -->
    <div id="pause-screen">
        <div id="pause-header">
            <h1 class="title-1">Wonder</h1>
            <h1 class="title-2">World</h1>
            <p class="version">Version Alpha.8.3.6</p>
        </div>
        <div id="pause-buttons">
            <button id="pause-resume">Resume</button>
            <button id="pause-settings">Settings</button>
            <button id="pause-save">Save World</button>
            <button id="pause-quit">Quit World</button>
        </div>
    </div>
    <!-- END: Pause Screen HTML -->



    <!-- Load Three.js from a CDN -->
    <script src="./js/utils/three.min.js"></script>

    <!-- ImprovedNoise with Random Permutation -->
    <script>
    const none = null;

    const loadingText = [
        "You can fly by double-tapping the jump button.",
        "You will be able to toggle between game modes by pressing the 'O' key.",
        "You can now double-tap the 'W' key to run faster.",
        "What kind of builds will you create, today?",
        "In Wonder World Version Alpha.8.3.6, you can only place dirt.",
        "Did you know, most of Wonder World's code was written by AI?",
        "<span style='font-size: 7px;'>If you can read this, you're probably sitting too close to the screen!</span>",  
        "Pressing buttons does things. Some of them useful, some of them… interesting.",  
        "Wonder World is made with magic, hope, and at least two gallons of coffee.",  
        "Tried to make the water wet. Turns out, it was already wet.",  
        "Every update adds something. What that something is… remains classified.",  
        "Achievement Unlocked: You found the loading screen!",  
        "Physics? Who needs physics in a game world?",  
        "Remember: If something is acting weird, it's not a bug. It's a feature.",  
        "Breaking news: Wonder World still doesn't have ray tracing. But hey, the sun works!",
    ]

    // A watcher object to watch for certain things.
    // As of right now, it only watches for game packs.

    /*
       The **Default** pack must always be somewhere in this array. If it isn't, it will be added.
       All pack data must be stored in the 'gamePacks' directory except for the **Default** pack.
       If there were a pack named "NewPack", it's name would be added to this array,
       and the data would be stored in the 'gamePacks/NewPack' directory.
       The **Default** pack's data is in the data folder.
    */
    const WATCHER = {
        gamePacks: ["**Default**"]
    };
    
    // Game Pack Data Collection System
    const GamePackLoader = {
        loadedPacks: new Map(),
        
        // Initialize and load all game packs
        async initialize() {
            console.log("Initializing GamePack system...");
            
            // Ensure **Default** pack is in the array
            if (!WATCHER.gamePacks.includes("**Default**")) {
                WATCHER.gamePacks.unshift("**Default**");
            }
            
            // Load all game packs
            for (const packName of WATCHER.gamePacks) {
                try {
                    await this.loadGamePack(packName);
                } catch (error) {
                    console.error(`Failed to load game pack "${packName}":`, error);
                }
            }
            
            console.log(`Loaded ${this.loadedPacks.size} game packs:`, Array.from(this.loadedPacks.keys()));
        },
        
        // Load a specific game pack
        async loadGamePack(packName) {
            console.log(`Loading game pack: ${packName}`);
            
            const packData = {
                name: packName,
                isDefault: packName === "**Default**",
                basePath: packName === "**Default**" ? "data/" : `gamePacks/${packName}/`,
                blocks: {},
                biomes: {},
                textures: {},
                structures: {},
                config: {}
            };
            
            // Load pack configuration
            try {
                packData.config = await this.loadPackConfig(packData.basePath);
            } catch (error) {
                console.warn(`No config found for pack "${packName}"`);
                packData.config = {};
            }
            
            // Load blocks data
            try {
                packData.blocks = await this.loadPackBlocks(packData.basePath);
            } catch (error) {
                console.warn(`No blocks data found for pack "${packName}"`);
            }
            
            // Load biomes data
            try {
                packData.biomes = await this.loadPackBiomes(packData.basePath);
            } catch (error) {
                console.warn(`No biomes data found for pack "${packName}"`);
            }
            
            // Load textures data
            try {
                packData.textures = await this.loadPackTextures(packData.basePath);
            } catch (error) {
                console.warn(`No textures data found for pack "${packName}"`);
            }
            
            // Load structures data
            try {
                packData.structures = await this.loadPackStructures(packData.basePath);
            } catch (error) {
                console.warn(`No structures data found for pack "${packName}"`);
            }
            
            this.loadedPacks.set(packName, packData);
            return packData;
        },
        
        // Load pack configuration
        async loadPackConfig(basePath) {
            const response = await fetch(`${basePath}config.json`);
            if (!response.ok) throw new Error(`Config not found at ${basePath}config.json`);
            return await response.json();
        },
        
        // Load blocks data
        async loadPackBlocks(basePath) {
            const response = await fetch(`${basePath}blocks.json`);
            if (!response.ok) throw new Error(`Blocks not found at ${basePath}blocks.json`);
            return await response.json();
        },
        
        // Load biomes data
        async loadPackBiomes(basePath) {
            const response = await fetch(`${basePath}biomes.json`);
            if (!response.ok) throw new Error(`Biomes not found at ${basePath}biomes.json`);
            return await response.json();
        },
        
        // Load textures data
        async loadPackTextures(basePath) {
            const response = await fetch(`${basePath}textures.json`);
            if (!response.ok) throw new Error(`Textures not found at ${basePath}textures.json`);
            return await response.json();
        },
        
        // Load structures data
        async loadPackStructures(basePath) {
            const response = await fetch(`${basePath}structures.json`);
            if (!response.ok) throw new Error(`Structures not found at ${basePath}structures.json`);
            return await response.json();
        },
        
        // Get data from a specific pack
        getPackData(packName) {
            return this.loadedPacks.get(packName);
        },
        
        // Get merged data from all packs (with priority order)
        getMergedData(dataType) {
            const merged = {};
            
            // Apply packs in order (later packs override earlier ones)
            for (const packName of WATCHER.gamePacks) {
                const packData = this.loadedPacks.get(packName);
                if (packData && packData[dataType]) {
                    Object.assign(merged, packData[dataType]);
                }
            }
            
            return merged;
        },
        
        // Get all available pack names
        getPackNames() {
            return Array.from(this.loadedPacks.keys());
        },
        
        // Check if a pack is loaded
        isPackLoaded(packName) {
            return this.loadedPacks.has(packName);
        },
        
        // Reload a specific pack
        async reloadPack(packName) {
            if (this.loadedPacks.has(packName)) {
                this.loadedPacks.delete(packName);
            }
            return await this.loadGamePack(packName);
        },
        
        // Get pack info for debugging
        getPackInfo() {
            const info = {};
            for (const [packName, packData] of this.loadedPacks) {
                info[packName] = {
                    isDefault: packData.isDefault,
                    basePath: packData.basePath,
                    hasConfig: Object.keys(packData.config).length > 0,
                    blockCount: Object.keys(packData.blocks).length,
                    biomeCount: Object.keys(packData.biomes).length,
                    textureCount: Object.keys(packData.textures).length,
                    structureCount: Object.keys(packData.structures).length
                };
            }
            return info;
        }
    };
    
    // Function to apply game pack data to existing game systems
    function applyGamePackData() {
        console.log("Applying game pack data to game systems...");
        
        // Merge and apply blocks data
        const packedBlocks = GamePackLoader.getMergedData('blocks');
        if (packedBlocks && packedBlocks.blocks && Object.keys(packedBlocks.blocks).length > 0) {
            console.log(`Loaded ${Object.keys(packedBlocks.blocks).length} blocks from game packs`);
            
            // Populate BLOCK_TYPES with block IDs
            Object.keys(packedBlocks.blocks).forEach(blockName => {
                const blockData = packedBlocks.blocks[blockName];
                if (blockData.id) {
                    BLOCK_TYPES[blockName] = blockData.id;
                }
            });
            
            // Populate blockColors with block properties
            Object.keys(packedBlocks.blocks).forEach(blockName => {
                const blockData = packedBlocks.blocks[blockName];
                if (blockData.properties) {
                    blockColors[blockName] = blockData.properties;
                    console.log(`Loaded block ${blockName}:`, blockColors[blockName]);
                }
            });
        }
        
        // Merge and apply biomes data
        const packedBiomes = GamePackLoader.getMergedData('biomes');
        if (packedBiomes && packedBiomes.biomes && Object.keys(packedBiomes.biomes).length > 0) {
            console.log(`Loaded ${Object.keys(packedBiomes.biomes).length} biomes from game packs`);
            
            // Populate BIOMES with biome data
            Object.assign(BIOMES, packedBiomes.biomes);
            
            // Debug: Show all loaded biomes with their temperature/moisture
            console.log("Loaded biomes:", Object.keys(BIOMES).map(name => ({
                name,
                temp: BIOMES[name].temperature,
                moisture: BIOMES[name].moisture,
                universal: BIOMES[name].isUniversalBiome
            })));
        }
        
        // Merge and apply structures data
        const packedStructures = GamePackLoader.getMergedData('structures');
        if (packedStructures && packedStructures.structures && Object.keys(packedStructures.structures).length > 0) {
            console.log(`Loaded ${Object.keys(packedStructures.structures).length} structures from game packs`);
            
            // Note: StructureGenerators functions remain hardcoded as they contain complex logic
            // Only structure metadata is loaded from GamePacks
        }
        
        // Apply configuration data
        const packedConfig = GamePackLoader.getMergedData('config');
        if (packedConfig && packedConfig.config) {
            const config = packedConfig.config;
            
            // Apply terrain configuration
            if (config.terrain) {
                if (config.terrain.geologicalFormations) {
                    Object.assign(GEOLOGICAL_FORMATIONS, config.terrain.geologicalFormations);
                }
                
                if (config.terrain.noiseConfig) {
                    Object.assign(NOISE_CONFIG, config.terrain.noiseConfig);
                }
                
                if (config.terrain.terrainBounds) {
                    Object.assign(TERRAIN_BOUNDS, config.terrain.terrainBounds);
                }
            }
            
            // Apply world settings
            if (config.world) {
                if (config.world.defaultBiome) defaultBiome = config.world.defaultBiome;
            }
        }
        
        // Log summary
        const packInfo = GamePackLoader.getPackInfo();
        console.log("Game Pack Summary:", packInfo);
        console.log("Game pack data applied successfully");
        
        // Load textures after all block data is ready
        loadBlockTextures();
    }
    
    // Utility functions for game pack management
    const GamePackUtils = {
        // Get all available blocks from all packs
        getAllBlocks() {
            return GamePackLoader.getMergedData('blocks');
        },
        
        // Get all available biomes from all packs
        getAllBiomes() {
            return GamePackLoader.getMergedData('biomes');
        },
        
        // Get all available structures from all packs
        getAllStructures() {
            return GamePackLoader.getMergedData('structures');
        },
        
        // Check if a specific pack has certain data
        packHasData(packName, dataType) {
            const packData = GamePackLoader.getPackData(packName);
            return packData && packData[dataType] && Object.keys(packData[dataType]).length > 0;
        },
        
        // Get combined configuration from all packs
        getCombinedConfig() {
            const combined = {};
            for (const packName of WATCHER.gamePacks) {
                const packData = GamePackLoader.getPackData(packName);
                if (packData && packData.config) {
                    Object.assign(combined, packData.config);
                }
            }
            return combined;
        },
        
        // Debug function to list all loaded content
        debugPackContents() {
            console.log("=== GAME PACK DEBUG INFO ===");
            for (const packName of WATCHER.gamePacks) {
                const packData = GamePackLoader.getPackData(packName);
                if (packData) {
                    console.log(`\n--- ${packName} ---`);
                    console.log(`Path: ${packData.basePath}`);
                    console.log(`Blocks: ${Object.keys(packData.blocks).length}`);
                    console.log(`Biomes: ${Object.keys(packData.biomes).length}`);
                    console.log(`Structures: ${Object.keys(packData.structures).length}`);
                    console.log(`Config keys: ${Object.keys(packData.config)}`);
                }
            }
            console.log("\n=== MERGED DATA ===");
            console.log(`Total Blocks: ${Object.keys(GamePackLoader.getMergedData('blocks')).length}`);
            console.log(`Total Biomes: ${Object.keys(GamePackLoader.getMergedData('biomes')).length}`);
            console.log(`Total Structures: ${Object.keys(GamePackLoader.getMergedData('structures')).length}`);
        }
    };
    
    // Add a seeded random generator function:
    function seededRandomGenerator(seed) {
        var m = 0x80000000; // 2^31
        var a = 1103515245;
        var c = 12345;
        var g = 7499755 * seed / c;
        var u = c - seed * g;

        var state = seed ? seed : Math.floor(g * m % seed);

        return function() {
            state = (a * (state ) + c) % m;
            return state / (m - 1);
        };
    }
    // Replace your ImprovedNoise implementation with:
    var ImprovedNoise = function () {
        var seededRandom = seededRandomGenerator(worldSeed);
        var p = [];
        // Use a seeded random permutation
        for (var i = 0; i < 256; i++) {
            p[i] = Math.floor(seededRandom() * 256);
        }
        var permutation = new Array(512);
        for (var i = 0; i < 256; i++) {
            permutation[i] = p[i];
            permutation[i + 256] = p[i];
        }
        function fade(t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
        }
        function lerp(t, a, b) {
            return a + t * (b - a);
        }
        function grad(hash, x, y, z) {
            var h = hash & 15;
            var u = h < 8 ? x : y;
            var v = h < 4 ? y : (h === 12 || h === 14 ? x : z);
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }
        return {
            noise: function (x, y, z) {
                var floorX = Math.floor(x),
                    floorY = Math.floor(y),
                    floorZ = Math.floor(z);
                var X = floorX & 255,
                    Y = floorY & 255,
                    Z = floorZ & 255;
                x -= floorX;
                y -= floorY;
                z -= floorZ;
                var u = fade(x),
                    v = fade(y),
                    w = fade(z);
                var A = permutation[X] + Y,
                    AA = permutation[A] + Z,
                    AB = permutation[A + 1] + Z;
                var B = permutation[X + 1] + Y,
                    BA = permutation[B] + Z,
                    BB = permutation[B + 1] + Z;
                return lerp(
                    w,
                    lerp(
                        v,
                        lerp(u, grad(permutation[AA], x, y, z), grad(permutation[BA], x - 1, y, z)),
                        lerp(u, grad(permutation[AB], x, y - 1, z), grad(permutation[BB], x - 1, y - 1, z))
                    ),
                    lerp(
                        v,
                        lerp(u, grad(permutation[AA + 1], x, y, z - 1), grad(permutation[BA + 1], x - 1, y, z - 1)),
                        lerp(u, grad(permutation[AB + 1], x, y - 1, z - 1), grad(permutation[BB + 1], x - 1, y - 1, z - 1))
                    )
                );
            }
        };
    };
    </script>

    <!-- Main Game Script -->
    <script>
    /********************************************
     * World Data
     ********************************************/
    // Global World Constants & Variables
    const CHUNK_SIZE = 16;         // Blocks per side of a chunk
    const WORLD_HEIGHT = 216;        // Vertical blocks per chunk
    const WORLD_CHUNK_COUNT = 100;   // World chunk grid
    const VISIBLE_RADIUS = 12;        // Load chunks within a certain radius

    // Chunk Loading Queue
    const MAX_CHUNKS_PER_FRAME = 5; // Maximum chunks to load per frame
    const chunkWorker = new Worker('chunkWorker.js'); // A separate worker script for chunk generation
    const pendingChunks = new Map(); // Track chunks being processed by worker

    // The LOADING_REQUIREMENTS constant is used to define how the loading screen will behave.
    // "Local" means it only need to load and render chunks within the visible radius.
    // "Global" means it needs to preload all chunks in the world and render the local ones.
    const LOADING_REQUIREMENTS = "Local"; // NOT IMPLEMENTED YET

    // Load saved world data if available before chunk generation
    const loadSavedWorldPromise = (async function loadSavedWorld() {
        try {
            const response = await fetch('/savedWorlds/alphaWorld/world.json');
            if (response.ok) {
                const data = await response.json();
                chunkDataStore = data;
                console.log('Loaded saved world data.');
            } else {
                console.log('No saved world file found. Generating new world.');
            }
        } catch (err) {
            console.error('Error loading saved world:', err);
        }
    })();

    // START: Loading Screen Logic
    let isLoading = true;
    let forcePlay = false; // Force play to skip loading screen (for testing)
    const loadingScreenEl = document.getElementById('loading-screen');
    const loadingBarEl = document.getElementById('loading-progress-bar');
    const loadingTextEl = document.getElementById('loading-text');
    let loadedInitialChunksCount = 0;
    let loadingStartTime = Date.now();
    let minLoadingTime = 2000; // Minimum loading time in ms
    let hasStartedChunkLoading = false;
    
    // We'll use a dynamic loading approach - load a minimum number of chunks around the player
    let totalInitialChunksToLoad = Math.min(25, (2 * 3 + 1) ** 2); // Load at least 25 chunks or 7x7 area
    
    function showRandomLoadingText() {
        const idx = Math.floor(Math.random() * loadingText.length);
        loadingTextEl.innerHTML = loadingText[idx];
    }
    function updateLoadingBar() {
        const timePassed = Date.now() - loadingStartTime;
        const timeProgress = Math.min(timePassed / minLoadingTime, 1);
        const chunkProgress = Math.min(loadedInitialChunksCount / totalInitialChunksToLoad, 1);
        
        // Use the maximum of time-based and chunk-based progress
        const pct = Math.max(timeProgress, chunkProgress) * 100;
        loadingBarEl.style.width = pct + '%';
        
        // Complete loading if we have minimum chunks AND minimum time has passed
        if ((loadedInitialChunksCount >= Math.min(totalInitialChunksToLoad, 10) && timePassed >= minLoadingTime) || forcePlay) {
            loadingTextEl.innerHTML = "Loading complete!";
            clearInterval(loadingInterval);
            setTimeout(completeLoading, 500);
        }
    }
    // Called when each initial chunk finishes loading
    function chunkLoaded() {
        loadedInitialChunksCount++;
        updateLoadingBar();
    }
    function completeLoading() {
        loadingScreenEl.style.display = 'none';
        isLoading = false;
        // Prompt for pointer lock after user click
        document.addEventListener('click', function unlockPointer() {
          renderer.domElement.requestPointerLock();
          document.removeEventListener('click', unlockPointer);
        });
    }
    // Show loading screen and start text updates
    loadingScreenEl.style.display = 'flex';
    showRandomLoadingText();
    let loadingInterval = setInterval(showRandomLoadingText, 10000);
    updateLoadingBar();
    // END: Loading Screen Logic

    // Biome Data  
    /********************************************
     * Important Biome Data Notes:
     * 
     *   **TRANSITION** The transition value can be set to "None", "Mostly", or "Full"
     *   "None" means no transition between biomes. It may look a bit choppy for some biomes.
     *   "Mostly" means that the transition between biomes is mostly smooth. Some sections may look choppy while others are smooth.
     *   "Full" means that the transition between biomes is very smooth. Great for mountains and such.
     * 
     *   **LAYERS** The layers value is an array of objects. Each object has a type and number value.
     *   The layers are rendered from top to bottom till either the layer placing is complete, or reaches the very bottom of the chunk.
     *   If the layers are completed, the defaultLayer is used for the remaining blocks.
     * 
     *   The type is the block type. The number is the number of blocks of the type.
     *   The number can be a solid number made using an integer, or a string.
     *   There are three types of strings:
     *   Range "[min]-[max]": The number of blocks will be a random number between min and max.
     *   Single Number "[number]": The number of blocks will be number.
     *   Coordinates "$[yMin]-[yMax]": The number of blocks will be a random number between min and max.
     *********************************************/
    // BIOMES will be populated by GamePack data
    const BIOMES = {};

    // Configuration objects will be populated by GamePack data
    const GEOLOGICAL_FORMATIONS = {};
    const TERRAIN_BOUNDS = {};
    const NOISE_CONFIG = {};

    // === ADVANCED TERRAIN GENERATION FUNCTIONS ===

    // Multi-octave noise generator with domain warping
    class AdvancedNoiseGenerator {
        constructor(seed) {
            this.seed = seed;
            this.noiseGen = new ImprovedNoise(); // Use existing noise generator
        }

        // Generate multi-octave noise
        multiOctaveNoise(x, z, config) {
            let value = 0;
            let amplitude = config.amplitude;
            let frequency = config.frequency;
            let maxValue = 0;

            for (let i = 0; i < config.octaves; i++) {
                value += this.noiseGen.noise(x * frequency, 0, z * frequency) * amplitude;
                maxValue += amplitude;
                amplitude *= 0.5;
                frequency *= 2.0;
            }

            return value / maxValue;
        }

        // Domain-warped noise for more organic patterns
        domainWarpedNoise(x, z, config, warpStrength = 50) {
            const warpX = this.noiseGen.noise(x * 0.01, 0, z * 0.01) * warpStrength;
            const warpZ = this.noiseGen.noise(x * 0.01, 100, z * 0.01) * warpStrength;
            
            return this.multiOctaveNoise(x + warpX, z + warpZ, config);
        }

        // Ridged noise for mountain ridges and valleys
        ridgedNoise(x, z, config) {
            let value = 0;
            let amplitude = config.amplitude;
            let frequency = config.frequency;

            for (let i = 0; i < config.octaves; i++) {
                let n = Math.abs(this.noiseGen.noise(x * frequency, 0, z * frequency));
                n = 1.0 - n;
                n = n * n;
                value += n * amplitude;
                amplitude *= 0.5;
                frequency *= 2.0;
            }

            return value;
        }
    }

    // Temperature and Moisture-based biome compatibility checker
    function areBiomesCompatible(biome1, biome2) {
        if (!BIOMES[biome1] || !BIOMES[biome2]) return false;
        
        const b1 = BIOMES[biome1];
        const b2 = BIOMES[biome2];
        
        // Universal biomes can be adjacent to any biome
        if (b1.isUniversalBiome || b2.isUniversalBiome) return true;
        
        // Check explicit compatibility lists first
        if (b1.compatibleBiomes && !b1.compatibleBiomes.includes(biome2)) return false;
        if (b1.blockedBiomes && b1.blockedBiomes.includes(biome2)) return false;
        if (b2.compatibleBiomes && !b2.compatibleBiomes.includes(biome1)) return false;
        if (b2.blockedBiomes && b2.blockedBiomes.includes(biome1)) return false;
        
        // Calculate temperature and moisture compatibility
        const tempDiff = Math.abs(b1.temperature - b2.temperature);
        const moistureDiff = Math.abs(b1.moisture - b2.moisture);
        
        // More lenient compatibility - temperature difference < 50 and moisture difference < 0.6
        return tempDiff < 50 && moistureDiff < 0.6;
    }

    // Calculate biome transition type based on transition attributes
    function getBiomeTransitionType(biome1, biome2) {
        if (!BIOMES[biome1] || !BIOMES[biome2]) return 'incompatible';
        if (!areBiomesCompatible(biome1, biome2)) return 'incompatible';
        
        const b1 = BIOMES[biome1];
        const b2 = BIOMES[biome2];
        
        // Handle mixed transition types
        if (b1.transition === "Auto" && b2.transition === "Auto") return 'mixed';
        if (b1.transition === "Auto") return b2.transition.toLowerCase();
        if (b2.transition === "Auto") return b1.transition.toLowerCase();
        
        // Both have specific transition types - use the more restrictive one
        const transitions = [b1.transition, b2.transition];
        if (transitions.includes("None")) return 'none';
        if (transitions.includes("Steep")) return 'steep';
        if (transitions.includes("Gentle")) return 'gentle';
        
        return 'gentle'; // Default fallback
    }

    // Get transition slope steepness based on transition type
    function getTransitionSteepness(transitionType, heightDiff) {
        switch(transitionType) {
            case 'none': return heightDiff; // Immediate cliff/drop
            case 'steep': return heightDiff * 0.7; // Steep but not vertical
            case 'gentle': return heightDiff * 0.3; // Gradual slope
            case 'mixed': return heightDiff * 0.5; // Moderate slope
            default: return heightDiff * 0.4; // Default moderate
        }
    }

    // Generate continental-scale elevation
    function generateContinentalElevation(x, z, noiseGen) {
        const continentalNoise = noiseGen.multiOctaveNoise(x, z, NOISE_CONFIG.continental);
        const regionalNoise = noiseGen.multiOctaveNoise(x, z, NOISE_CONFIG.regional);
        
        // Create landmasses and ocean basins
        const continentalShape = continentalNoise * 0.7 + regionalNoise * 0.3;
        const baseElevation = TERRAIN_BOUNDS.sea_level + continentalShape;
        
        return Math.max(TERRAIN_BOUNDS.min_elevation, baseElevation);
    }

    // Detect and apply geological formations
    function applyGeologicalFormations(x, z, baseElevation, noiseGen) {
        const formationNoise = noiseGen.multiOctaveNoise(x, z, NOISE_CONFIG.formation);
        const formationStrength = Math.abs(formationNoise);
        
        let finalElevation = baseElevation;
        
        // Determine formation type based on noise characteristics
        if (formationStrength > 0.7) {
            // Mesa or plateau formation
            const mesa = GEOLOGICAL_FORMATIONS.MESA;
            const plateauNoise = noiseGen.ridgedNoise(x, z, { frequency: 0.008, amplitude: 15, octaves: 2 });
            finalElevation += plateauNoise * mesa.elevation_modifier;
            
            // Add cliff edges
            const edgeNoise = Math.abs(noiseGen.noiseGen.noise(x * 0.02, 0, z * 0.02));
            if (edgeNoise > 0.6) {
                finalElevation += mesa.edge_steepness * (edgeNoise - 0.6) * 10;
            }
        } else if (formationStrength > 0.4) {
            // Ridge formation
            const ridge = GEOLOGICAL_FORMATIONS.RIDGE;
            const ridgeNoise = noiseGen.ridgedNoise(x, z, { frequency: 0.015, amplitude: 20, octaves: 3 });
            finalElevation += ridgeNoise * ridge.elevation_modifier;
        } else if (formationNoise < -0.4) {
            // Valley formation
            const valley = GEOLOGICAL_FORMATIONS.VALLEY;
            const valleyDepth = Math.abs(formationNoise + 0.4) * 30;
            finalElevation -= valleyDepth * valley.elevation_modifier;
        }
        
        return finalElevation;
    }

    // Enhanced biome selection with Temperature/Moisture compatibility
    function selectBiomeWithAdjacency(x, z, noiseGen, existingBiomes) {
        const biomeNoise = noiseGen.domainWarpedNoise(x, z, NOISE_CONFIG.biome_warp);
        const elevation = generateContinentalElevation(x, z, noiseGen);
        
        // Generate temperature and moisture values based on location and noise
        const temperatureNoise = noiseGen.multiOctaveNoise(x * 0.001, z * 0.001, { frequency: 0.02, amplitude: 1, octaves: 3 });
        const moistureNoise = noiseGen.multiOctaveNoise(x * 0.0015, z * 0.0015, { frequency: 0.025, amplitude: 1, octaves: 4 });
        
        // Simpler temperature calculation - range from 10°F to 130°F to match our biomes
        const baseTemp = 70 + temperatureNoise * 60; // Range: 10°F to 130°F
        const baseMoisture = Math.max(0, Math.min(1, 0.5 + moistureNoise * 0.5)); // Range: 0.0 to 1.0
        
        // Debug logging for biome selection
        if (Math.random() < 0.01) { // Only log 1% of the time to avoid spam
            console.log(`Biome selection at (${x}, ${z}): temp=${baseTemp.toFixed(1)}°F, moisture=${baseMoisture.toFixed(2)}, elevation=${elevation.toFixed(1)}`);
        }
        
        // Find biomes with similar temperature and moisture
        let suitableBiomes = Object.keys(BIOMES).filter(biomeName => {
            const biome = BIOMES[biomeName];
            
            // Check elevation suitability
            const elevationDiff = Math.abs(elevation - biome.baseHeight);
            if (elevationDiff > biome.heightVariation * 2) return false;
            
            // Universal biomes are always suitable
            if (biome.isUniversalBiome) return true;
            
            // Check temperature and moisture compatibility
            const tempDiff = Math.abs(baseTemp - biome.temperature);
            const moistDiff = Math.abs(baseMoisture - biome.moisture);
            
            return tempDiff < 45 && moistDiff < 0.5;
        });
        
        // Debug logging for suitable biomes
        if (Math.random() < 0.01) {
            console.log(`Suitable biomes at (${x}, ${z}):`, suitableBiomes);
            console.log(`Available biomes:`, Object.keys(BIOMES).map(name => ({
                name,
                temp: BIOMES[name].temperature,
                moisture: BIOMES[name].moisture,
                baseHeight: BIOMES[name].baseHeight
            })));
        }
        
        // Check adjacency with existing biomes
        const nearbyBiomes = getNearbyBiomes(x, z, existingBiomes, 100);
        if (nearbyBiomes.length > 0) {
            suitableBiomes = suitableBiomes.filter(biomeName => {
                const biome = BIOMES[biomeName];
                
                // Universal biomes can be placed anywhere
                if (biome.isUniversalBiome) return true;
                
                // Check compatibility with nearby biomes
                return nearbyBiomes.some(nearbyBiome => 
                    areBiomesCompatible(biomeName, nearbyBiome)
                );
            });
        }
        
        // If no suitable biomes found, fallback to all biomes to ensure variety
        if (suitableBiomes.length === 0) {
            suitableBiomes = Object.keys(BIOMES);
        }
        
        // Select biome based on weighted probability
        const weights = suitableBiomes.map(biomeName => {
            const biome = BIOMES[biomeName];
            const rarityWeight = biome.rarity / 100;
            
            // Prefer biomes with closer temperature/moisture match
            const tempMatch = 1 - Math.min(1, Math.abs(baseTemp - biome.temperature) / 50);
            const moistMatch = 1 - Math.min(1, Math.abs(baseMoisture - biome.moisture) / 1);
            const matchBonus = (tempMatch + moistMatch) / 2;
            
            return rarityWeight * matchBonus;
        });
        
        // Weighted random selection
        const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
        const randomValue = Math.abs(biomeNoise) * totalWeight;
        
        let currentWeight = 0;
        for (let i = 0; i < suitableBiomes.length; i++) {
            currentWeight += weights[i];
            if (randomValue <= currentWeight) {
                return suitableBiomes[i];
            }
        }
        
        return suitableBiomes[0]; // Fallback
    }

    // Get nearby biomes for adjacency checking
    function getNearbyBiomes(x, z, existingBiomes, radius) {
        const nearbyBiomes = [];
        const checkRadius = radius;
        
        for (let dx = -checkRadius; dx <= checkRadius; dx += 50) {
            for (let dz = -checkRadius; dz <= checkRadius; dz += 50) {
                const key = `${Math.floor((x + dx) / 50)},${Math.floor((z + dz) / 50)}`;
                if (existingBiomes.has(key)) {
                    const biome = existingBiomes.get(key);
                    if (!nearbyBiomes.includes(biome)) {
                        nearbyBiomes.push(biome);
                    }
                }
            }
        }
        
        return nearbyBiomes;
    }

    // Calculate sophisticated height with all factors
    function calculateSophisticatedHeight(x, z, biomeName, noiseGen, neighborBiomes) {
        const biome = BIOMES[biomeName];
        
        // Base continental elevation
        let elevation = generateContinentalElevation(x, z, noiseGen);
        
        // Apply geological formations
        elevation = applyGeologicalFormations(x, z, elevation, noiseGen);
        
        // Local biome-specific terrain
        const localNoise = noiseGen.multiOctaveNoise(x, z, NOISE_CONFIG.local);
        const detailNoise = noiseGen.multiOctaveNoise(x, z, NOISE_CONFIG.detail);
        const microNoise = noiseGen.multiOctaveNoise(x, z, NOISE_CONFIG.micro);
        
        // Combine local terrain features
        let biomeModification = localNoise * biome.heightVariation * 0.6;
        biomeModification += detailNoise * biome.heightVariation * 0.3;
        biomeModification += microNoise * biome.heightVariation * 0.1;
        
        // Apply biome-specific terrain characteristics
        if (biomeName.includes('mountain') || biomeName.includes('peaks')) {
            // Use ridged noise for mountain peaks
            const ridgedTerrain = noiseGen.ridgedNoise(x, z, { frequency: 0.02, amplitude: 30, octaves: 4 });
            biomeModification += ridgedTerrain;
        } else if (biomeName.includes('desert') || biomeName.includes('dunes')) {
            // Use domain warping for sand dunes
            const duneNoise = noiseGen.domainWarpedNoise(x, z, { frequency: 0.03, amplitude: 15, octaves: 3 }, 30);
            biomeModification += duneNoise * 0.8;
        } else if (biomeName.includes('ocean') || biomeName.includes('lake')) {
            // Smooth underwater terrain
            biomeModification *= 0.3;
        }
        
        // Smooth transitions between neighboring biomes
        if (neighborBiomes && neighborBiomes.length > 0) {
            let transitionWeight = 0;
            let transitionSum = 0;
            
            neighborBiomes.forEach(neighbor => {
                const transitionType = getBiomeTransitionType(biomeName, neighbor.biome);
                if (transitionType !== 'incompatible') {
                    const distance = Math.sqrt(
                        Math.pow(x - neighbor.x, 2) + Math.pow(z - neighbor.z, 2)
                    );
                    const weight = Math.max(0, 1 - distance / 200);
                    
                    if (weight > 0) {
                        const neighborBiome = BIOMES[neighbor.biome];
                        const neighborHeight = neighborBiome.baseHeight + 
                                              neighborBiome.heightVariation * localNoise * 0.5;
                        
                        transitionSum += neighborHeight * weight;
                        transitionWeight += weight;
                    }
                }
            });
            
            if (transitionWeight > 0) {
                const averageNeighborHeight = transitionSum / transitionWeight;
                const blendFactor = Math.min(0.4, transitionWeight);
                elevation = elevation * (1 - blendFactor) + averageNeighborHeight * blendFactor;
            }
        }
        
        // Apply final biome modification
        elevation += biomeModification;
        
        // Ensure within bounds
        elevation = Math.max(TERRAIN_BOUNDS.min_elevation, 
                           Math.min(TERRAIN_BOUNDS.max_elevation, elevation));
        
        // Update dynamic bounds if adaptive
        if (TERRAIN_BOUNDS.adaptive_min && elevation < TERRAIN_BOUNDS.min_elevation + TERRAIN_BOUNDS.safety_margin) {
            TERRAIN_BOUNDS.min_elevation = Math.min(TERRAIN_BOUNDS.min_elevation, elevation - TERRAIN_BOUNDS.safety_margin);
        }
        if (TERRAIN_BOUNDS.adaptive_max && elevation > TERRAIN_BOUNDS.max_elevation - TERRAIN_BOUNDS.safety_margin) {
            TERRAIN_BOUNDS.max_elevation = Math.max(TERRAIN_BOUNDS.max_elevation, elevation + TERRAIN_BOUNDS.safety_margin);
        }
        
        return Math.floor(elevation);
    }

    // Enhanced structure placement logic
    function shouldPlaceStructure(x, y, z, structure, biomeName, terrainSlope, moistureLevel) {
        const baseFrequency = structure.frequency / 100;
        let placementProbability = baseFrequency;
        
        // Adjust based on terrain slope
        if (structure.type === 'tree') {
            // Trees prefer gentler slopes
            placementProbability *= Math.max(0.1, 1 - terrainSlope * 2);
            // Trees prefer moderate moisture
            placementProbability *= Math.max(0.3, 1 - Math.abs(moistureLevel - 0.5));
        } else if (structure.type === 'house') {
            // Houses prefer flat areas
            placementProbability *= Math.max(0.05, 1 - terrainSlope * 4);
            // Houses avoid water areas
            placementProbability *= moistureLevel < 0.7 ? 1 : 0.1;
        }
        
        // Biome-specific adjustments
        if (biomeName.includes('mountain') || biomeName.includes('peaks')) {
            placementProbability *= 0.3; // Fewer structures on mountains
        } else if (biomeName.includes('forest')) {
            if (structure.type === 'tree') placementProbability *= 1.5;
        }
        
        return Math.random() < placementProbability;
    }

    // Add a mapping for block type strings
    // BLOCK_TYPES will be populated by GamePack data
    const BLOCK_TYPES = {};

    // Structure Generators - Methods for generating different structures
    const StructureGenerators = {
        // Generate a tree at the given position
        tree: function(data, x, y, z) {
            const height = 4 + Math.floor(Math.random() * 3); // Tree height 4-6 blocks
            const leafRadius = 2;
            
            // Generate trunk
            for (let dy = 0; dy < height; dy++) {
                if (y + dy >= WORLD_HEIGHT) break;
                data[x][y + dy][z] = BLOCK_TYPES.wood;
            }
            
            // Generate leaves
            for (let dx = -leafRadius; dx <= leafRadius; dx++) {
                for (let dy = -1; dy <= 2; dy++) {
                    for (let dz = -leafRadius; dz <= leafRadius; dz++) {
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        if (dist <= leafRadius + 0.5) {
                            const lx = x + dx;
                            const ly = y + height - 1 + dy;
                            const lz = z + dz;
                            if (lx >= 0 && lx < CHUNK_SIZE && 
                                ly >= 0 && ly < WORLD_HEIGHT && 
                                lz >= 0 && lz < CHUNK_SIZE) {
                                if (data[lx][ly][lz] === 0) {
                                    data[lx][ly][lz] = BLOCK_TYPES.leaves;
                                }
                            }
                        }
                    }
                }
            }
        },
        
        // Generate a house at the given position
        house: function(data, x, y, z) {
            const width = 5;
            const length = 7;
            const height = 4;
            
            // Check if we have enough space in chunk
            if (x + width >= CHUNK_SIZE || z + length >= CHUNK_SIZE) return;
            if (y + height >= WORLD_HEIGHT) return;
            
            // Generate floor
            for (let dx = 0; dx < width; dx++) {
                for (let dz = 0; dz < length; dz++) {
                    data[x + dx][y][z + dz] = BLOCK_TYPES.stone;
                }
            }
            
            // Generate walls
            for (let dy = 1; dy < height; dy++) {
                for (let dx = 0; dx < width; dx++) {
                    for (let dz = 0; dz < length; dz++) {
                        // Skip if it's not a wall block
                        if (dx > 0 && dx < width - 1 && dz > 0 && dz < length - 1) continue;
                        data[x + dx][y + dy][z + dz] = BLOCK_TYPES.wood;
                    }
                }
            }
            
            // Generate roof
            for (let dx = 0; dx < width; dx++) {
                for (let dz = 0; dz < length; dz++) {
                    data[x + dx][y + height][z + dz] = BLOCK_TYPES.wood;
                }
            }
            
            // Add a door (2 blocks high)
            const doorX = x + Math.floor(width / 2);
            const doorZ = z;
            data[doorX][y + 1][doorZ] = 0;
            data[doorX][y + 2][doorZ] = 0;
            
            // Add windows
            const windowY = y + 2;
            // Front windows
            data[x + 1][windowY][z] = 0;
            data[x + width - 2][windowY][z] = 0;
            // Back windows
            data[x + 1][windowY][z + length - 1] = 0;
            data[x + width - 2][windowY][z + length - 1] = 0;
            // Side windows
            data[x][windowY][z + Math.floor(length / 2)] = 0;
            data[x + width - 1][windowY][z + Math.floor(length / 2)] = 0;
        }
    };

    // blockColors will be populated by GamePack data
    const blockColors = {};

    let defaultBiome = "plains"; // Default biome to use if none is specified

    // Texture support: preload textures for blocks that specify an image path in blockColors
    const textureLoader = new THREE.TextureLoader();
    textureLoader.crossOrigin = "anonymous";
    
    // Function to handle texture loading errors
    function onTextureLoadError(blockName, texturePath) {
        console.error(`Failed to load texture for ${blockName}: ${texturePath}`);
    }

    // Helper function to create worker constants
    function getWorkerConstants() {
        return {
            CHUNK_SIZE,
            WORLD_HEIGHT,
            BLOCK_TYPES,
            BIOMES,
            worldSeed,
            blockColors: getSerializableBlockProperties(blockColors),
            GEOLOGICAL_FORMATIONS,
            TERRAIN_BOUNDS,
            NOISE_CONFIG,
            AdvancedNoiseGenerator: AdvancedNoiseGenerator.toString(),
            StructureGenerators: {
                tree: StructureGenerators.tree.toString(),
                house: StructureGenerators.house.toString()
            }
        };
    }

    // Function to load textures for all blocks
    function loadBlockTextures() {
        console.log("Loading block textures...");
        
        // Load textures for each block type
        Object.entries(blockColors).forEach(([name, props]) => {
            console.log(`Processing textures for block ${name}:`, props);
            // Handle base texture
            if (typeof props.color === 'string') {
                // Check if it's a hex color (starts with #) or a texture path
                if (props.color.startsWith('#')) {
                    // It's a hex color - convert to THREE.Color
                    props.color = new THREE.Color(props.color);
                    console.log(`Applied hex color for ${name}:`, props.color);
                } else {
                    // It's a texture path - load the texture
                    try {
                    props.texture = textureLoader.load(
                        props.color,
                        (texture) => {
                            // Enable transparency for the texture
                            texture.premultiplyAlpha = true;
                            texture.format = THREE.RGBAFormat;
                            // Store the block name in the texture's userData for later reference
                            texture.userData = { blockName: name };
                        },
                        undefined,
                        () => onTextureLoadError(name, props.color)
                    );
                    props.texture.wrapS = THREE.RepeatWrapping;
                    props.texture.wrapT = THREE.RepeatWrapping;
                    props.color = new THREE.Color(0xffffff);
                } catch (e) {
                    console.error(`Error loading texture for ${name}:`, e);
                    props.color = new THREE.Color(0xff00ff); // Fallback color
                }
            }
        }
        
        // Handle per-face textures
        if (props.faces) {
            Object.entries(props.faces).forEach(([face, val]) => {
                if (typeof val === 'string') {
                    // Check if it's a hex color or texture path
                    if (val.startsWith('#')) {
                        // It's a hex color
                        props.faces[face] = {
                            color: new THREE.Color(val)
                        };
                        console.log(`Applied hex color for ${name} ${face}:`, val);
                    } else {
                        // It's a texture path
                        try {
                        const texture = textureLoader.load(
                            val,
                            (texture) => {
                                // Enable transparency for the texture
                                texture.premultiplyAlpha = true;
                                texture.format = THREE.RGBAFormat;
                                texture.userData = { blockName: name };
                            },
                            undefined,
                            () => onTextureLoadError(name, val)
                        );
                        texture.wrapS = THREE.RepeatWrapping;
                        texture.wrapT = THREE.RepeatWrapping;
                        props.faces[face] = {
                            texture: texture,
                            color: props.color || new THREE.Color(0xffffff)
                        };
                    } catch (e) {
                        console.error(`Error loading face texture for ${name}:`, e);
                        props.faces[face] = {
                            color: new THREE.Color(0xff00ff) // Fallback color
                        };
                    }
                }
                }
            });
        }
    });
    
    console.log("Block textures loaded successfully");
    }

    // Helper to map BLOCK_TYPES number back to its name.
    function getBlockName(blockTypeNumber) {
        return Object.keys(BLOCK_TYPES).find(key => BLOCK_TYPES[key] === blockTypeNumber);
    }

    // Player collision and movement parameters.
    const playerHeight = 1.8;       
    const playerRadius = 0.3;       
    const jumpImpulse = 13; 
    const worldSeed = 2000;        

    // Global variables for rendering, scene, and input.
    let scene, renderer;
    let camera, yawObject;
    let pitch = 0;
    let controlsEnabled = false;
    let velocity = new THREE.Vector3();
    let prevTime = performance.now();
    let moveForward = false,
        moveBackward = false,
        moveLeft = false,
        moveRight = false;
    let canJump = false;
    let lastPlayerChunkX = null, lastPlayerChunkZ = null;
    let loadedChunks = {};    // keys: "cx,cz" -> mesh
    let chunkDataStore = {};  // keys: "cx,cz" -> 3D block array
    
    // Add frustum for visibility checking
    const cameraFrustum = new THREE.Frustum();
    const cameraViewMatrix = new THREE.Matrix4();
    
    // Use a priority queue for chunk loading
    class PriorityQueue {
        constructor() {
            this.items = [];
        }
        
        enqueue(item, priority) {
            const queueItem = { item, priority };
            let contain = false;
            
            for (let i = 0; i < this.items.length; i++) {
                if (this.items[i].priority > priority) {
                    this.items.splice(i, 0, queueItem);
                    contain = true;
                    break;
                }
            }
            
            if (!contain) {
                this.items.push(queueItem);
            }
        }
        
        dequeue() {
            if (this.isEmpty()) return null;
            return this.items.shift().item;
        }
        
        isEmpty() {
            return this.items.length === 0;
        }
        
        clear() {
            this.items = [];
        }
        
        size() {
            return this.items.length;
        }
        
        contains(key) {
            return this.items.some(item => item.item.key === key);
        }
        
        // Prune chunks from the queue that no longer meet criteria
        prune(shouldKeepFn) {
            this.items = this.items.filter(queueItem => shouldKeepFn(queueItem.item));
        }
    }
    
    const chunkQueue = new PriorityQueue();

    // Noise generator and raycaster for block interactions.
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    // Global running detection.
    let lastWPressTime = 0;
    let isRunning = false;

    // Add global flying variables:
    let isFlying = false;
    let lastJumpTapTime = 0;
    let flyUp = false;
    let flyDown = false;

    // Add global game mode variable (default "normal")
    let gameMode = "normal"; // "normal" or "spectator"

    // FPS and game info tracking
    let fpsCounter = 0;
    let fpsLastTime = performance.now();
    let currentFPS = 0;
    let chunkUpdatesThisSecond = 0;
    let chunkUpdatesLastTime = performance.now();
    let showDebugInfo = true; // Toggle for debug info display

    // Function to get the current biome at player position
    function getCurrentBiome(x, z) {
        // Use the improved biome selection algorithm
        return selectBiomeWithSeed(x, z, worldSeed);
    }

    // Seed-driven biome selection with natural distribution
    function selectBiomeWithSeed(x, z, seed) {
        // Create seeded noise generator
        const noiseGen = new ImprovedNoise();
        
        // Use multiple noise layers for natural biome distribution
        const biomeScale = 0.0008; // Base scale for biome regions
        const detailScale = 0.003; // Detail noise for variation
        const warpScale = 0.0015; // Domain warping for organic shapes
        
        // Apply domain warping for organic biome shapes
        const warpX = noiseGen.noise((x + seed) * warpScale, seed * 0.001, z * warpScale) * 200;
        const warpZ = noiseGen.noise(x * warpScale, (seed + 1000) * 0.001, (z + seed) * warpScale) * 200;
        
        const warpedX = x + warpX;
        const warpedZ = z + warpZ;
        
        // Generate base biome noise
        const biomeNoise = noiseGen.noise(warpedX * biomeScale, seed * 0.01, warpedZ * biomeScale);
        const detailNoise = noiseGen.noise(warpedX * detailScale, (seed + 500) * 0.01, warpedZ * detailScale);
        const elevationNoise = noiseGen.noise(x * 0.001, (seed + 1500) * 0.01, z * 0.001);
        
        // Combine noises for biome selection
        const combinedNoise = (biomeNoise + detailNoise * 0.3 + elevationNoise * 0.2) / 1.5;
        const normalizedNoise = (combinedNoise + 1) / 2; // Normalize to 0-1
        
        // Create biome weight array based on rarity and size
        const biomeWeights = [];
        const biomeNames = Object.keys(BIOMES);
        
        for (const biomeName of biomeNames) {
            const biome = BIOMES[biomeName];
            // Weight combines rarity (how often it appears) and size (how large regions are)
            const weight = (biome.rarity / 100) * biome.size * biome.size;
            biomeWeights.push({ name: biomeName, weight: weight, biome: biome });
        }
        
        // Sort by weight for better distribution
        biomeWeights.sort((a, b) => b.weight - a.weight);
        
        // Calculate elevation for biome filtering
        const elevation = 65 + elevationNoise * 80; // Rough elevation estimate
        
        // Filter biomes by elevation compatibility
        const suitableBiomes = biomeWeights.filter(item => {
            const heightDiff = Math.abs(elevation - item.biome.baseHeight);
            return heightDiff < item.biome.heightVariation * 1.5;
        });
        
        if (suitableBiomes.length === 0) {
            return "plains"; // Fallback
        }
        
        // Calculate cumulative weights
        let totalWeight = 0;
        for (const item of suitableBiomes) {
            totalWeight += item.weight;
        }
        
        // Select biome based on noise value
        let target = normalizedNoise * totalWeight;
        for (const item of suitableBiomes) {
            target -= item.weight;
            if (target <= 0) {
                return item.name;
            }
        }
        
        return suitableBiomes[0].name;
    }

    // Enhanced biome selection with Temperature/Moisture adjacency checking
    function selectBiomeWithAdjacency(x, z, noiseGen, existingBiomes, seed) {
        // Create seeded noise generator for consistent biome placement
        const seededNoise = new ImprovedNoise();
        
        // Generate temperature and moisture based on location and seed
        const tempNoise = seededNoise.noise((x + seed) * 0.001, seed * 0.01, z * 0.001);
        const moistNoise = seededNoise.noise(x * 0.0015, (seed + 1000) * 0.01, (z + seed) * 0.0015);
        const elevationNoise = seededNoise.noise(x * 0.002, (seed + 2000) * 0.01, z * 0.002);
        
        // Calculate realistic temperature (affected by latitude and elevation)
        const elevation = 65 + elevationNoise * 80;
        const baseTemp = 70 + tempNoise * 60; // Simplified: 10°F to 130°F range
        const baseMoisture = Math.max(0, Math.min(1, 0.5 + moistNoise * 0.5)); // 0.0 to 1.0 range
        
        // Find biomes with compatible temperature and moisture
        let suitableBiomes = Object.keys(BIOMES).filter(biomeName => {
            const biome = BIOMES[biomeName];
            
            // Check elevation suitability
            const elevationDiff = Math.abs(elevation - biome.baseHeight);
            if (elevationDiff > biome.heightVariation * 2) return false;
            
            // Universal biomes are always suitable
            if (biome.isUniversalBiome) return true;
            
            // Check temperature and moisture compatibility
            const tempDiff = Math.abs(baseTemp - biome.temperature);
            const moistDiff = Math.abs(baseMoisture - biome.moisture);
            
            return tempDiff < 45 && moistDiff < 0.5;
        });
        
        // Check adjacency with existing biomes if any exist
        const nearbyBiomes = getNearbyBiomes(x, z, existingBiomes, 150);
        if (nearbyBiomes.length > 0) {
            suitableBiomes = suitableBiomes.filter(biomeName => {
                const biome = BIOMES[biomeName];
                
                // Universal biomes can always be placed
                if (biome.isUniversalBiome) return true;
                
                // Check explicit compatibility lists first
                if (biome.compatibleBiomes) {
                    return nearbyBiomes.some(nearby => biome.compatibleBiomes.includes(nearby));
                }
                
                if (biome.blockedBiomes) {
                    return !nearbyBiomes.some(nearby => biome.blockedBiomes.includes(nearby));
                }
                
                // Default temperature/moisture compatibility
                return nearbyBiomes.some(nearbyBiome => 
                    areBiomesCompatible(biomeName, nearbyBiome)
                );
            });
        }
        
        // Fallback to universal biomes if no suitable biomes found
        if (suitableBiomes.length === 0) {
            suitableBiomes = Object.keys(BIOMES).filter(biomeName => 
                BIOMES[biomeName].isUniversalBiome
            );
        }
        
        // Final fallback
        if (suitableBiomes.length === 0) {
            suitableBiomes = ['plains', 'ocean'];
        }
        
        // Select biome using weighted probability based on rarity and climate match
        const weights = suitableBiomes.map(biomeName => {
            const biome = BIOMES[biomeName];
            const rarityWeight = biome.rarity / 100;
            
            // Calculate climate match bonus
            const tempMatch = 1 - Math.min(1, Math.abs(baseTemp - biome.temperature) / 60);
            const moistMatch = 1 - Math.min(1, Math.abs(baseMoisture - biome.moisture) / 1);
            const climateMatch = (tempMatch + moistMatch) / 2;
            
            return rarityWeight * climateMatch;
        });
        
        // Weighted random selection using seeded noise
        const biomeNoise = seededNoise.noise(x * 0.005, seed * 0.01, z * 0.005);
        const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
        const randomValue = Math.abs(biomeNoise) * totalWeight;
        
        let currentWeight = 0;
        for (let i = 0; i < suitableBiomes.length; i++) {
            currentWeight += weights[i];
            if (randomValue <= currentWeight) {
                return suitableBiomes[i];
            }
        }
        
        return suitableBiomes[0]; // Fallback
    }

    // Function to update game info display
    function updateGameInfo() {
        const playerPos = yawObject.position;
        const chunksInMemory = Object.keys(chunkDataStore).length;
        const chunksLoaded = Object.keys(loadedChunks).length;
        const chunksInQueue = chunkQueue.size();
        const entities = 0; // Not implemented yet
        const chunksBeingProcessed = pendingChunks.size;
        
        // Format position to 2 decimal places
        const posX = playerPos.x.toFixed(2);
        const posY = playerPos.y.toFixed(2);
        const posZ = playerPos.z.toFixed(2);
        
        // Calculate chunk coordinates
        const chunkX = Math.floor(playerPos.x / CHUNK_SIZE);
        const chunkZ = Math.floor(playerPos.z / CHUNK_SIZE);
        
        // Get current biome
        const currentBiome = getCurrentBiome(playerPos.x, playerPos.z);
        const biomeData = BIOMES[currentBiome];
        const biomeDisplayName = currentBiome.charAt(0).toUpperCase() + currentBiome.slice(1).replace(/_/g, ' ');
        
        // Create status indicators
        const statusIndicators = [];
        if (isFlying) statusIndicators.push('<span style="color: #ffff00;">Flying</span>');
        if (isInWater()) statusIndicators.push('<span style="color: #00ffff;">In Water</span>');
        if (isRunning) statusIndicators.push('<span style="color: #00ff00;">Running</span>');
        
        // Update info display
        const infoElement = document.getElementById('info');
        infoElement.innerHTML = `
            <div style="background: rgba(0,0,0,0.7); padding: 10px; border-radius: 6px; font-size: 11px; line-height: 1.5; font-family: 'Courier New', monospace; max-width: 280px;">
                <div style="font-size: 13px; font-weight: bold; margin-bottom: 8px; color: #ffffff;">Wonder World - Alpha.8.3.6</div>
                
                <div style="margin-bottom: 6px;">
                    <div style="color: #88ff88;">Performance:</div>
                    <div style="margin-left: 10px;">FPS: <span style="color: ${currentFPS >= 60 ? '#00ff00' : currentFPS >= 30 ? '#ffff00' : '#ff0000'}">${currentFPS}</span></div>
                </div>
                
                <div style="margin-bottom: 6px;">
                    <div style="color: #88ccff;">Chunks:</div>
                    <div style="margin-left: 10px;">
                        Memory: ${chunksInMemory}<br>
                        Loaded: ${chunksLoaded}<br>
                        Queue: ${chunksInQueue}<br>
                        Processing: ${chunksBeingProcessed}<br>
                        Updates/sec: ${chunkUpdatesThisSecond}
                    </div>
                </div>
                
                <div style="margin-bottom: 6px;">
                    <div style="color: #ffcc88;">Position:</div>
                    <div style="margin-left: 10px;">
                        World: ${posX}, ${posY}, ${posZ}<br>
                        Chunk: ${chunkX}, ${chunkZ}
                    </div>
                </div>
                
                <div style="margin-bottom: 6px;">
                    <div style="color: #90EE90;">Biome:</div>
                    <div style="margin-left: 10px;">
                        <span style="color: #98FB98;">${biomeDisplayName}</span><br>
                        Height: ${biomeData ? biomeData.baseHeight : 'N/A'}±${biomeData ? biomeData.heightVariation : 'N/A'}<br>
                        Rarity: ${biomeData ? biomeData.rarity : 'N/A'}%
                    </div>
                </div>
                
                <div style="margin-bottom: 6px;">
                    <div style="color: #ff88ff;">Game:</div>
                    <div style="margin-left: 10px;">
                        Mode: ${gameMode}<br>
                        Entities: ${entities}
                    </div>
                </div>
                
                <div style="margin-bottom: 6px;">
                    <div style="color: #FFB6C1;">Game Packs:</div>
                    <div style="margin-left: 10px;">
                        Active: ${WATCHER.gamePacks.length}<br>
                        Loaded: ${GamePackLoader ? GamePackLoader.getPackNames().length : 0}<br>
                        ${WATCHER.gamePacks.slice(0, 3).map(pack => 
                            pack === '**Default**' ? '<span style="color: #90EE90;">Default</span>' : 
                            `<span style="color: #87CEEB;">${pack}</span>`
                        ).join(', ')}${WATCHER.gamePacks.length > 3 ? '...' : ''}
                    </div>
                </div>
                
                ${statusIndicators.length > 0 ? `<div style="margin-top: 8px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.3);">${statusIndicators.join(' • ')}</div>` : ''}
            </div>
        `;
    }

    const KEY = {}

    // Remove pointer lock if any touch event occurs:
    document.addEventListener("touchstart", function(e) {
        if (document.pointerLockElement) {
            document.exitPointerLock();
        }
    }, { passive: true });

    /********************************************
     * Methods
     ********************************************/
    // Cylinder-Based Collision Helpers
    function collidesCylinder(posY, posX, posZ) {
        const baseY = posY;
        const topY = posY + playerHeight;
        for (let bx = Math.floor(posX - playerRadius); bx <= Math.floor(posX + playerRadius); bx++) {
            for (let bz = Math.floor(posZ - playerRadius); bz <= Math.floor(posZ + playerRadius); bz++) {
                for (let by = Math.floor(baseY); by < Math.floor(topY) + 1; by++) {
                    // changed code: ignore water blocks
                    const block = getBlockAt(bx, by, bz);
                    if (block && block !== BLOCK_TYPES.water) {
                        if ((by < topY) && (by + 1 > baseY)) {
                            const nearestX = Math.max(bx, Math.min(posX, bx + 1));
                            const nearestZ = Math.max(bz, Math.min(posZ, bz + 1));
                            const dx = posX - nearestX;
                            const dz = posZ - nearestZ;
                            if (Math.sqrt(dx * dx + dz * dz) < playerRadius) return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    function resolveHorizontalCollisions() {
        let iterations = 0;
        while (iterations < 5) {
            let posX = yawObject.position.x;
            let posZ = yawObject.position.z;
            let correction = new THREE.Vector2(0, 0);
            let collided = false;
            const baseY = yawObject.position.y;
            const topY = baseY + playerHeight;
            for (let bx = Math.floor(posX - playerRadius); bx <= Math.floor(posX + playerRadius); bx++) {
                for (let bz = Math.floor(posZ - playerRadius); bz <= Math.floor(posZ + playerRadius); bz++) {
                    for (let by = Math.floor(baseY); by < Math.floor(topY) + 1; by++) {
                        // changed code: ignore water blocks
                        const block = getBlockAt(bx, by, bz);
                        if (block && block !== BLOCK_TYPES.water) {
                            if ((by < topY) && (by + 1 > baseY)) {
                                const nearestX = Math.max(bx, Math.min(posX, bx + 1));
                                const nearestZ = Math.max(bz, Math.min(posZ, bz + 1));
                                let dx = posX - nearestX;
                                let dz = posZ - nearestZ;
                                let dist = Math.sqrt(dx * dx + dz * dz);
                                if (dist < playerRadius) {
                                    let overlap = playerRadius - dist;
                                    if (dist === 0) {
                                        dx = 0.01;
                                        dz = 0.01;
                                        dist = Math.sqrt(dx * dx + dz * dz);
                                    }
                                    const nx = dx / dist;
                                    const nz = dz / dist;
                                    correction.x += nx * overlap;
                                    correction.y += nz * overlap;
                                    collided = true;
                                }
                            }
                        }
                    }
                }
            }
            if (collided) {
                yawObject.position.x += correction.x;
                yawObject.position.z += correction.y;
            } else {
                break;
            }
            iterations++;
        }
    }

    // Block & Chunk Helpers
    function getBlockAt(globalX, globalY, globalZ) {
        if (globalY < 0 || globalY >= WORLD_HEIGHT) return 0;
        const cx = Math.floor(globalX / CHUNK_SIZE);
        const cz = Math.floor(globalZ / CHUNK_SIZE);
        if (cx < 0 || cx >= WORLD_CHUNK_COUNT || cz < 0 || cz >= WORLD_CHUNK_COUNT) return 0;
        
        // Get block from chunk data
        const key = `${cx},${cz}`;
        const chunkData = chunkDataStore[key];
        if (!chunkData) {
            // For unloaded chunks, queue them for loading
            queueChunkLoad(cx, cz);
            return 0; // Return air for now
        }
        
        const localX = globalX - cx * CHUNK_SIZE;
        const localZ = globalZ - cz * CHUNK_SIZE;
        if (localX < 0 || localX >= CHUNK_SIZE || localZ < 0 || localZ >= CHUNK_SIZE) return 0;
        
        const block = chunkData[localX][globalY][localZ];
        return block;
    }

    // Helper function to check if player is in water
    function isInWater() {
        const pos = yawObject.position;
        const x = Math.floor(pos.x);
        const y = Math.floor(pos.y);
        const z = Math.floor(pos.z);
        
        // Check blocks at player's body (from feet to head)
        for (let dy = 0; dy <= Math.ceil(playerHeight); dy++) {
            if (getBlockAt(x, y + dy, z) === BLOCK_TYPES.water) {
                return true;
            }
        }
        return false;
    }

    function getBlockInChunk(chunkData, x, y, z) {
        if (y < 0 || y >= WORLD_HEIGHT) return 0;
        
        // Convert to global coordinates
        const globalX = chunkData.chunkX * CHUNK_SIZE + x;
        const globalZ = chunkData.chunkZ * CHUNK_SIZE + z;
        
        // Use getBlockAt for any coordinates - it will handle chunk boundaries
        return getBlockAt(globalX, y, globalZ);
    }

    const faces = [
        { // Left face (-X)
        dir: [-1, 0, 0],
        vertices: [
            [0, 0, 1],
            [0, 1, 1],
            [0, 1, 0],
            [0, 0, 0],
        ]
        },
        { // Right face (+X)
        dir: [1, 0, 0],
        vertices: [
            [1, 0, 0],
            [1, 1, 0],
            [1, 1, 1],
            [1, 0, 1],
        ]
        },
        { // Bottom face (-Y)
        dir: [0, -1, 0],
        vertices: [
            [0, 0, 0],
            [1, 0, 0],
            [1, 0, 1],
            [0, 0, 1],
        ]
        },
        { // Top face (+Y)
        dir: [0, 1, 0],
        vertices: [
            [0, 1, 1],
            [1, 1, 1],
            [1, 1, 0],
            [0, 1, 0],
        ]
        },
        { // Back face (-Z)
        dir: [0, 0, -1],
        vertices: [
            [1, 0, 0],
            [0, 0, 0],
            [0, 1, 0],
            [1, 1, 0],
        ]
        },
        { // Front face (+Z)
        dir: [0, 0, 1],
        vertices: [
            [0, 0, 1],
            [1, 0, 1],
            [1, 1, 1],
            [0, 1, 1],
        ]
        }
    ];
    // Add mapping from face index to face name for styling
    const faceNames = ["left", "right", "bottom", "top", "back", "front"];

    // Chunk geometry is now built in the worker

    // Chunk Management
    function loadChunk(cx, cz) {
        const key = `${cx},${cz}`;
        if (loadedChunks[key]) return;
        
        let chunkData = chunkDataStore[key];
        if (!chunkData) {
            // Queue chunk for generation by worker
            queueChunkLoad(cx, cz);
            
            // Also queue neighboring chunks to ensure proper face culling
            const neighbors = [
                [cx - 1, cz], [cx + 1, cz],
                [cx, cz - 1], [cx, cz + 1]
            ];
            
            for (const [ncx, ncz] of neighbors) {
                if (ncx >= 0 && ncx < WORLD_CHUNK_COUNT && 
                    ncz >= 0 && ncz < WORLD_CHUNK_COUNT) {
                    queueChunkLoad(ncx, ncz);
                }
            }
            return;
        }
        
        // Request geometry data from the worker
        pendingChunks.set(key, true);
        chunkWorker.postMessage({
            cx, 
            cz,
            requestGeometry: true,
            constants: getWorkerConstants()
        });
        // The worker will compute and return the geometry
        const group = new THREE.Group();
        
        // Add opaque meshes first
        if (geoms.opaque) {
            const opaqueMaterial = new THREE.MeshLambertMaterial({
                vertexColors: true,
                side: THREE.FrontSide,
                transparent: false
            });
            group.add(new THREE.Mesh(geoms.opaque, opaqueMaterial));
        }
        
        // Add textured meshes next, sorting by transparency
        for (const texturedMesh of geoms.textured) {
            const blockName = texturedMesh.texture.userData?.blockName;
            const blockProps = blockColors[blockName] || {};
            
            const material = new THREE.MeshLambertMaterial({
                map: texturedMesh.texture,
                transparent: true,
                side: blockProps.sideRendering === "both" ? THREE.DoubleSide : THREE.FrontSide,
                opacity: blockProps.transparency || 1,
                alphaTest: blockProps.alphaTest || 0.1,
                depthWrite: blockProps.transparency === 1 // Only write to depth buffer for fully opaque blocks
            });
            const mesh = new THREE.Mesh(texturedMesh.geometry, material);
            mesh.renderOrder = blockProps.transparency < 1 ? 1 : 0; // Render transparent blocks last
            group.add(mesh);
        }
        
        // Add transparent meshes last
        if (geoms.transparent) {
            const transparentMaterial = new THREE.MeshLambertMaterial({
                vertexColors: true,
                side: blockColors.water.sideRendering === "both" ? THREE.DoubleSide : THREE.FrontSide,
                transparent: true,
                depthWrite: false,
                opacity: blockColors.water.transparency
            });
            const mesh = new THREE.Mesh(geoms.transparent, transparentMaterial);
            mesh.renderOrder = 1; // Render after opaque objects
            group.add(mesh);
        }
        
        scene.add(group);
        loadedChunks[key] = group;
    }

    function unloadChunk(cx, cz) {
        const key = `${cx},${cz}`;
        if (loadedChunks[key]) {
            scene.remove(loadedChunks[key]);
            loadedChunks[key].traverse(obj => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });
            delete loadedChunks[key];
        }
    }

    function updateChunk(cx, cz) {
        const key = `${cx},${cz}`;
        if (!chunkDataStore[key]) return;
        
        // Track chunk updates
        chunkUpdatesThisSecond++;
        
        // Don't remove the old mesh immediately - let it stay visible until new geometry is ready
        // The worker response handler will replace it when the new geometry arrives
        
        // Request geometry data from the worker
        pendingChunks.set(key, true);
        chunkWorker.postMessage({
            cx, 
            cz,
            requestGeometry: true,
            constants: getWorkerConstants()
        });
        const group = new THREE.Group();

        // Add opaque meshes first
        if (geoms.opaque) {
            const opaqueMaterial = new THREE.MeshLambertMaterial({
                vertexColors: true,
                side: THREE.FrontSide,
                transparent: false
            });
            const mesh = new THREE.Mesh(geoms.opaque, opaqueMaterial);
            mesh.renderOrder = 0;
            group.add(mesh);
        }

        // Add textured meshes next, sorting by transparency
        for (const texturedMesh of geoms.textured) {
            const blockName = texturedMesh.texture.userData?.blockName;
            const blockProps = blockColors[blockName] || {};
            
            const material = new THREE.MeshLambertMaterial({
                map: texturedMesh.texture,
                transparent: blockProps.transparency < 1,
                side: blockProps.sideRendering === "both" ? THREE.DoubleSide : THREE.FrontSide,
                opacity: blockProps.transparency || 1,
                alphaTest: blockProps.alphaTest || 0.1,
                depthWrite: blockProps.transparency === 1 // Only write to depth buffer for fully opaque blocks
            });
            const mesh = new THREE.Mesh(texturedMesh.geometry, material);
            mesh.renderOrder = blockProps.transparency < 1 ? 2 : 0; // Higher render order for transparent blocks
            group.add(mesh);
        }

        // Add transparent meshes last with highest render order
        if (geoms.transparent) {
            const transparentMaterial = new THREE.MeshLambertMaterial({
                vertexColors: true,
                side: blockColors.water.sideRendering === "both" ? THREE.DoubleSide : THREE.FrontSide,
                transparent: true,
                depthWrite: false,
                depthTest: true,
                opacity: blockColors.water.transparency,
                alphaTest: blockColors.water.alphaTest || 0.1
            });
            const mesh = new THREE.Mesh(geoms.transparent, transparentMaterial);
            mesh.renderOrder = 2; // Ensure water renders after other transparent objects
            group.add(mesh);
        }

        scene.add(group);
        loadedChunks[key] = group;
    }

    // Helper function to strip texture data from block properties
    function getSerializableBlockProperties(blockColors) {
        const serializableProps = {};
        for (const [name, props] of Object.entries(blockColors)) {
            serializableProps[name] = {
                transparency: props.transparency || 1,
                seeThrough: props.seeThrough || false,
                sideRendering: props.sideRendering || "one",
                color: props.color,
                // Include face information for proper geometry separation
                faces: props.faces ? Object.keys(props.faces).reduce((faceObj, faceName) => {
                    faceObj[faceName] = {
                        // We can't transfer textures, but we can mark that this face has a texture
                        hasTexture: !!props.faces[faceName].texture || typeof props.faces[faceName] === 'string',
                        color: props.faces[faceName].color
                    };
                    return faceObj;
                }, {}) : null,
                // Mark if this block has a default texture (from color property being a string)
                hasDefaultTexture: typeof props.color === 'string' || !!props.texture
            };
        }
        return serializableProps;
    }

    // Helper function to send chunk update to worker
    function sendChunkUpdate(cx, cz, chunkData) {
        chunkWorker.postMessage({
            type: "updateChunk",
            cx: cx,
            cz: cz,
            modifiedChunk: chunkData,
            constants: {
                blockColors: getSerializableBlockProperties(blockColors)
            }
        });
    }

    // Handle worker messages
    chunkWorker.onmessage = function(e) {
        const { cx, cz, geometryData, chunkData, type } = e.data;
        const key = `${cx},${cz}`;
        
        // Track chunk updates
        chunkUpdatesThisSecond++;
        
        // If we receive chunk data, store it
        if (chunkData) {
            chunkData.chunkX = cx;
            chunkData.chunkZ = cz;
            chunkDataStore[key] = chunkData;
        }
        
        // If we receive chunk data with no geometry, request geometry
        if (chunkData && !geometryData) {
            // Request geometry in a separate message
            pendingChunks.set(key, true);
            chunkWorker.postMessage({
                cx, 
                cz,
                requestGeometry: true,
                constants: getWorkerConstants()
            });
            
            if (isLoading) chunkLoaded();
            return;
        }
        
        // If we don't have geometry data, nothing to render
        if (!geometryData) {
            if (isLoading) chunkLoaded();
            return;
        }

        // Remove from pending queue
        pendingChunks.delete(key);

        // If this is an update for an existing chunk, remove old mesh
        if (loadedChunks[key]) {
            scene.remove(loadedChunks[key]);
            loadedChunks[key].traverse(obj => { if (obj.geometry) obj.geometry.dispose(); if (obj.material) obj.material.dispose(); });
        }

        // Build new group from raw geometryData
        const group = new THREE.Group();

        // Opaque
        if (geometryData.opaque && geometryData.opaque.indices.length) {
            const buf = geometryData.opaque;
            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', new THREE.BufferAttribute(buf.vertices, 3));
            geom.setAttribute('uv', new THREE.BufferAttribute(buf.uvs, 2));
            geom.setAttribute('color', new THREE.BufferAttribute(buf.colors, 3));
            geom.setIndex(new THREE.BufferAttribute(buf.indices, 1));
            geom.computeVertexNormals();
            const mat = new THREE.MeshLambertMaterial({ vertexColors: true, side: THREE.FrontSide });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.renderOrder = 0;
            group.add(mesh);
        }

        // Textured
        if (geometryData.textured) {
            for (const entry of geometryData.textured) {
                const buf = entry;
                const geom = new THREE.BufferGeometry();
                geom.setAttribute('position', new THREE.BufferAttribute(buf.vertices, 3));
                geom.setAttribute('uv', new THREE.BufferAttribute(buf.uvs, 2));
                geom.setIndex(new THREE.BufferAttribute(buf.indices, 1));
                geom.computeVertexNormals();
                
                // Get block and face info from the entry
                const blockName = entry.blockName || (entry.key ? entry.key.split('_')[0] : 'unknown');
                const faceName = entry.faceName || (entry.key && entry.key.includes('_') ? entry.key.split('_')[1] : null);
                
                // Get the texture based on block name and face
                let texture;
                if (blockName && faceName && blockColors[blockName]?.faces?.[faceName]?.texture) {
                    texture = blockColors[blockName].faces[faceName].texture;
                } else if (blockName && blockColors[blockName]?.texture) {
                    texture = blockColors[blockName].texture;
                } else if (blockName) {
                    // Debug - if we have the block name but no texture, show what's missing
                    console.log("Missing texture for block:", blockName, faceName ? `face: ${faceName}` : '');
                }
                
                const props = blockColors[blockName] || {};
                
                // Create material properties
                const matProps = {
                    transparent: props.transparency < 1,
                    side: props.sideRendering === 'both' ? THREE.DoubleSide : THREE.FrontSide,
                    opacity: props.transparency || 1,
                    alphaTest: props.alphaTest || 0.1,
                    depthWrite: props.transparency === 1
                };
                
                // Only add texture if it exists, otherwise use vertex colors
                if (texture) {
                    matProps.map = texture;
                } else {
                    // If no texture found, use a colored material based on block color
                    // First check if the worker sent a color, otherwise fall back to blockColors
                    const blockColor = entry.color || props.color || { r: 1, g: 1, b: 1 };
                    matProps.color = new THREE.Color(blockColor.r, blockColor.g, blockColor.b);
                    matProps.vertexColors = false;
                }
                
                const mat = new THREE.MeshLambertMaterial(matProps);
                const mesh = new THREE.Mesh(geom, mat);
                mesh.renderOrder = props.transparency < 1 ? 2 : 0;
                group.add(mesh);
            }
        }

        // Transparent
        if (geometryData.transparent && geometryData.transparent.indices.length) {
            const buf = geometryData.transparent;
            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', new THREE.BufferAttribute(buf.vertices, 3));
            geom.setAttribute('uv', new THREE.BufferAttribute(buf.uvs, 2));
            geom.setAttribute('color', new THREE.BufferAttribute(buf.colors, 3));
            geom.setIndex(new THREE.BufferAttribute(buf.indices, 1));
            geom.computeVertexNormals();
            const props = blockColors.water;
            const mat = new THREE.MeshLambertMaterial({
                vertexColors: true,
                transparent: true,
                depthWrite: false,
                side: props.sideRendering === 'both' ? THREE.DoubleSide : THREE.FrontSide,
                opacity: props.transparency,
                alphaTest: props.alphaTest || 0.1
            });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.renderOrder = 2;
            group.add(mesh);
        }

        // Add to scene and track
        scene.add(group);
        loadedChunks[key] = group;

        if (isLoading) chunkLoaded();
    };
    
    function queueChunkLoad(cx, cz) {
        const key = `${cx},${cz}`;
        if (loadedChunks[key] || chunkQueue.contains(key) || pendingChunks.has(key)) return;
        
        // Calculate distance to player for priority
        const playerChunkX = Math.floor(yawObject.position.x / CHUNK_SIZE);
        const playerChunkZ = Math.floor(yawObject.position.z / CHUNK_SIZE);
        const distance = Math.sqrt(Math.pow(cx - playerChunkX, 2) + Math.pow(cz - playerChunkZ, 2));
        
        // Add to priority queue with distance as priority (lower distance = higher priority)
        chunkQueue.enqueue({ cx, cz, key }, distance);
    }
    
    function processChunkQueue() {
        const startTime = performance.now();
        const TIME_BUDGET = 16; // Try to keep chunk processing under 16ms per frame
        
        while (!chunkQueue.isEmpty() && 
               pendingChunks.size < MAX_CHUNKS_PER_FRAME && 
               performance.now() - startTime < TIME_BUDGET) {
            
            const { cx, cz, key } = chunkQueue.dequeue();
            
            // Skip if chunk is already loaded or being processed
            if (loadedChunks[key] || pendingChunks.has(key)) continue;
            
            // Mark chunk as pending
            pendingChunks.set(key, true);
            
            // Send chunk generation request to worker with block properties
            // Always request geometry to be computed in the worker
            chunkWorker.postMessage({
                cx, 
                cz,
                requestGeometry: true,  // Always generate geometry in worker
                constants: getWorkerConstants()
            });
        }
    }
    
    function updateChunks() {
        const playerPos = yawObject.position;
        let playerChunkX = Math.floor(playerPos.x / CHUNK_SIZE);
        let playerChunkZ = Math.floor(playerPos.z / CHUNK_SIZE);
        playerChunkX = Math.max(0, Math.min(WORLD_CHUNK_COUNT - 1, playerChunkX));
        playerChunkZ = Math.max(0, Math.min(WORLD_CHUNK_COUNT - 1, playerChunkZ));
        
        // Update camera frustum
        camera.updateMatrix();
        camera.updateMatrixWorld();
        cameraViewMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        cameraFrustum.setFromProjectionMatrix(cameraViewMatrix);
        
        // During loading, prioritize loading chunks around the player first
        if (isLoading && !hasStartedChunkLoading) {
            hasStartedChunkLoading = true;
            // Load a 5x5 grid around player first for initial loading
            for (let dx = -2; dx <= 2; dx++) {
                for (let dz = -2; dz <= 2; dz++) {
                    const cx = playerChunkX + dx;
                    const cz = playerChunkZ + dz;
                    if (cx >= 0 && cx < WORLD_CHUNK_COUNT && cz >= 0 && cz < WORLD_CHUNK_COUNT) {
                        queueChunkLoad(cx, cz);
                    }
                }
            }
        }
        
        // Calculate how far to check for chunks in view based on view frustum
        const loadDistance = isLoading ? 3 : VISIBLE_RADIUS + 1; // Smaller radius during loading
        
        // Clear previous queue if player moved to a new chunk
        if (lastPlayerChunkX !== playerChunkX || lastPlayerChunkZ !== playerChunkZ) {
            if (!isLoading) { // Only clear queue after loading is complete
                chunkQueue.clear();
            }
            lastPlayerChunkX = playerChunkX;
            lastPlayerChunkZ = playerChunkZ;
        }
        
        // Prune chunks from queue that are no longer in view or too far away (only after loading)
        if (!isLoading) {
            const beforeCount = chunkQueue.size();
            chunkQueue.prune(({ cx, cz }) => {
                // Distance check
                const dx = cx - playerChunkX;
                const dz = cz - playerChunkZ;
                const distance = Math.sqrt(dx*dx + dz*dz);
                
                // Keep chunks within visible radius
                return distance <= VISIBLE_RADIUS;
            });
            const afterCount = chunkQueue.size();
            if (beforeCount !== afterCount) {
                console.log(`Pruned ${beforeCount - afterCount} chunks from queue (${beforeCount} -> ${afterCount})`);
            }
        }

        // Check chunks within visible radius and load them
        for (let dx = -loadDistance; dx <= loadDistance; dx++) {
            for (let dz = -loadDistance; dz <= loadDistance; dz++) {
                const cx = playerChunkX + dx;
                const cz = playerChunkZ + dz;
                
                if (cx < 0 || cx >= WORLD_CHUNK_COUNT || cz < 0 || cz >= WORLD_CHUNK_COUNT) {
                    continue;
                }
                
                // During loading, load all chunks in the smaller radius
                if (isLoading) {
                    queueChunkLoad(cx, cz);
                    continue;
                }
                
                // Load all chunks within the visible radius
                const distanceToPlayer = Math.sqrt(dx*dx + dz*dz);
                if (distanceToPlayer <= VISIBLE_RADIUS) {
                    queueChunkLoad(cx, cz);
                }
            }
        }

        // Unload chunks that are too far (only after loading is complete)
        if (!isLoading) {
            for (const key in loadedChunks) {
                const [cx, cz] = key.split(",").map(Number);
                
                // Distance-based culling only
                const dx = cx - playerChunkX;
                const dz = cz - playerChunkZ;
                const distance = Math.sqrt(dx*dx + dz*dz);
                
                // Only unload chunks that are beyond the visible radius
                if (distance > VISIBLE_RADIUS) {
                    unloadChunk(cx, cz);
                }
            }
        }
    }
    
    // Block Modification (Place / Break)
    function modifyBlockAt(worldPos, value) {
        // In spectator mode, disable interactions.
        if (gameMode === "spectator") return;
        
        const gx = Math.floor(worldPos.x);
        const gy = Math.floor(worldPos.y);
        const gz = Math.floor(worldPos.z);
        const cx = Math.floor(gx / CHUNK_SIZE);
        const cz = Math.floor(gz / CHUNK_SIZE);
        const key = `${cx},${cz}`;
        
        if (!chunkDataStore[key]) {
            console.log("Chunk not loaded. Cannot modify block.");
            return;
        }
        
        const localX = gx - cx * CHUNK_SIZE;
        const localZ = gz - cz * CHUNK_SIZE;
        
        if (gy < 0 || gy >= WORLD_HEIGHT) {
            console.log("Block coordinates out of range.");
            return;
        }
        
        // Modify the block
        chunkDataStore[key][localX][gy][localZ] = value;
        
        // Send update to worker and wait for response before updating visuals
        sendChunkUpdate(cx, cz, chunkDataStore[key]);

        // Update affected chunks
        const chunksToUpdate = new Set();
        chunksToUpdate.add(key);
        
        // Add neighboring chunks if we're on a boundary
        if (localX === 0 && cx > 0) chunksToUpdate.add(`${cx-1},${cz}`);
        if (localX === CHUNK_SIZE - 1 && cx < WORLD_CHUNK_COUNT - 1) chunksToUpdate.add(`${cx+1},${cz}`);
        if (localZ === 0 && cz > 0) chunksToUpdate.add(`${cx},${cz-1}`);
        if (localZ === CHUNK_SIZE - 1 && cz < WORLD_CHUNK_COUNT - 1) chunksToUpdate.add(`${cx},${cz+1}`);

        // Update all affected chunks
        for (const chunkKey of chunksToUpdate) {
            const [updateCx, updateCz] = chunkKey.split(',').map(Number);
            if (chunkDataStore[chunkKey]) {
                updateChunk(updateCx, updateCz);
            }
        }
    }

    // Initialization & Rendering & Input Handling
    async function init() {
        // Initialize GamePack system first
        try {
            await GamePackLoader.initialize();
            console.log("GamePack system initialized successfully");
            
            // Apply game pack data to existing systems
            applyGamePackData();
        } catch (error) {
            console.error("Failed to initialize GamePack system:", error);
            console.log("Continuing with default data...");
        }
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x88ccff);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 0.5);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -8;
        directionalLight.shadow.camera.right = 8;
        directionalLight.shadow.camera.top = 8;
        directionalLight.shadow.camera.bottom = -8;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        scene.add(directionalLight);

        // Set up camera and first-person hierarchy.
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Position the camera at 80% of the cylinder height (simulating the head).
        camera.position.set(0, 0.8 * playerHeight, 0);
        yawObject = new THREE.Object3D();
        
        // Place the player near the center of the world
        let startX = (WORLD_CHUNK_COUNT * CHUNK_SIZE) / 2;
        let startZ = (WORLD_CHUNK_COUNT * CHUNK_SIZE) / 2;
        let startY = 100; // Start high up and let gravity bring us down
        yawObject.position.set(startX, startY, startZ);

        // Remove direct addition of camera and add it to a new holder for water effect
        cameraEffect = new THREE.Object3D();
        cameraEffect.add(camera);
        yawObject.add(cameraEffect);
        scene.add(yawObject);
        
        // Preload visible chunks so the world is ready.
        updateChunks();
        
        // Setup Pointer Lock.
        const element = document.body;
        document.addEventListener("pointerlockchange", onPointerLockChange, false);
        document.addEventListener("pointerlockerror", onPointerLockError, false);
        document.addEventListener("mousemove", onMouseMove, false);
        document.addEventListener("mousedown", onMouseDown, false);
        window.addEventListener("keydown", onKeyDown, false);
        window.addEventListener("keyup", onKeyUp, false);
        window.addEventListener("resize", onWindowResize, false);

        animate();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onPointerLockChange() {
        controlsEnabled = !isLoading && (document.pointerLockElement === document.body);
        // Show or hide pause screen when unlocked
        const pauseEl = document.getElementById('pause-screen');
        if (!controlsEnabled && !isLoading) {
            pauseEl.style.display = 'flex';
        } else {
            pauseEl.style.display = 'none';
        }
    }
    function onPointerLockError() {
        console.error("PointerLock Error");
    }
    function onMouseMove(event) {
        if (!controlsEnabled) return;
        const movementX = event.movementX || 0;
        const movementY = event.movementY || 0;
        yawObject.rotation.y -= movementX * 0.002;
        pitch -= movementY * 0.002;
        pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
        camera.rotation.x = pitch;
    }

    function getMovementAcceleration(delta) {
        var transportationSpeed = 1;
        if (isFlying) {
            transportationSpeed = 2;
        }
        const forward = new THREE.Vector3(0, 0, -1)
        .applyAxisAngle(new THREE.Vector3(0, 1, 0), yawObject.rotation.y);
        const right = new THREE.Vector3(1, 0, 0)
        .applyAxisAngle(new THREE.Vector3(0, 1, 0), yawObject.rotation.y);
        const accel = new THREE.Vector3();
        if (moveForward) accel.add(forward);
        if (moveBackward) accel.sub(forward);
        if (moveLeft) accel.sub(right);
        if (moveRight) accel.add(right);
        if (accel.length() > 0) {
            // Use a higher multiplier when running.
            accel.normalize().multiplyScalar((isRunning ? 70 : 40) * transportationSpeed * delta);
        }
        return accel;
    }

    function onKeyDown(event) {
        const currentTime = performance.now();
        switch (event.code) {
        case "KeyW":
        case "ArrowUp":
            if (!moveForward && (currentTime - lastWPressTime < 300)) {
                isRunning = true;
            }
            lastWPressTime = currentTime;
            moveForward = true;
            KEY["Forward"] = true;
            break;
        case "KeyS":
        case "ArrowDown":
            moveBackward = true;
            KEY["Backward"] = true;
            break;
        case "KeyA":
        case "ArrowLeft":
            moveLeft = true;
            KEY["Left"] = true;
            break;
        case "KeyD":
        case "ArrowRight":
            moveRight = true;
            KEY["Right"] = true;
            break;
        case "Space":
            // Detect double tap on jump (threshold 300ms)
            if (currentTime - lastJumpTapTime < 300) {
                // Toggle flying mode only in normal mode and when not in water
                if (gameMode === "normal" && !isInWater()) {
                    isFlying = !isFlying;
                    console.log("Flying: " + isFlying);
                }
                lastJumpTapTime = 0;
                flyUp = false;
                flyDown = false;
                break;
            } else {
                lastJumpTapTime = currentTime;
                if (gameMode === "normal") {
                    if (isFlying) {
                        flyUp = true;
                    } else if (canJump) {
                        velocity.y = jumpImpulse;
                        canJump = false;
                    }
                } else {
                    // In spectator mode, always fly upward on jump tap
                    flyUp = true;
                }
            }
            KEY["Jump"] = true;
            break;
        case "ShiftLeft":
        case "ShiftRight":
            if (gameMode === "normal" && isFlying) {
                flyDown = true;
            } else if (gameMode === "spectator") {
                flyDown = true;
            }
            break;
        case "KeyO":
            // Toggle game mode between normal and spectator
            if (gameMode === "normal") {
                gameMode = "spectator";
                isFlying = true; // always flying
                console.log("Game Mode: Spectator");
            } else {
                gameMode = "normal";
                isFlying = false; // revert to normal flying state
                console.log("Game Mode: Normal");
            }
            break;
        case "F3":
            // Toggle debug info display
            event.preventDefault(); // Prevent browser dev tools
            showDebugInfo = !showDebugInfo;
            console.log("Debug Info: " + (showDebugInfo ? "On" : "Off"));
            break;
        }
    }

    function onKeyUp(event) {
        switch (event.code) {
        case "KeyW":
        case "ArrowUp":
            moveForward = false;
            isRunning = false;
            break;
        case "KeyS":
        case "ArrowDown":
            moveBackward = false;
            break;
        case "KeyA":
        case "ArrowLeft":
            moveLeft = false;
            break;
        case "KeyD":
        case "ArrowRight":
            moveRight = false;
            break;
        case "Space":
            flyUp = false;
            break;
        case "ShiftLeft":
        case "ShiftRight":
            flyDown = false;
            break;
        }
    }

    // Block Interaction via Raycasting
    function onMouseDown(event) {
        // In spectator mode, disable interactions.
        if (gameMode === "spectator") return;
        // Disable mining/placing when pointer lock not active
        if (!controlsEnabled) return;
        // Set pointer coordinates: use screen coords when unlocked, center when locked
        if (document.pointerLockElement === document.body) {
            pointer.set(0, 0);
        } else {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }
        raycaster.setFromCamera(pointer, camera);
        // Include all meshes in nested groups
        const intersects = raycaster.intersectObjects(Object.values(loadedChunks), true);
        if (intersects.length >  0) {
        const intersect = intersects[0];
        if (event.button === 0) { // Left click: break block.
            const breakPos = new THREE.Vector3(
            Math.floor(intersect.point.x - intersect.face.normal.x * 0.01),
            Math.floor(intersect.point.y - intersect.face.normal.y * 0.01),
            Math.floor(intersect.point.z - intersect.face.normal.z * 0.01)
            );
            modifyBlockAt(breakPos, 0);
        } else if (event.button === 2) { // Right click: place block.
            const placePos = new THREE.Vector3(
            Math.floor(intersect.point.x + intersect.face.normal.x * 0.51),
            Math.floor(intersect.point.y + intersect.face.normal.y * 0.51),
            Math.floor(intersect.point.z + intersect.face.normal.z * 0.51)
            );
            modifyBlockAt(placePos, 2); // Place a dirt block by default.
            // You could modify this to allow players to select which material to place.
        }
        }
    }
    document.addEventListener("contextmenu", function (e) { e.preventDefault(); });

    // Animation, Physics & Collision Loop
    function animate() {
        requestAnimationFrame(animate);
        const time = performance.now();
        const delta = Math.min((time - prevTime) / 1000, 0.1);
        prevTime = time;

        // Calculate FPS
        fpsCounter++;
        if (time - fpsLastTime >= 1000) {
            currentFPS = Math.round((fpsCounter * 1000) / (time - fpsLastTime));
            fpsCounter = 0;
            fpsLastTime = time;
            
            // Reset chunk updates counter
            chunkUpdatesThisSecond = 0;
            chunkUpdatesLastTime = time;
        }

        // Update game info display every frame
        if (!isLoading && showDebugInfo) {
            updateGameInfo();
        } else if (!showDebugInfo) {
            // Hide debug info but keep version
            const infoElement = document.getElementById('info');
            infoElement.innerHTML = `
                <div style="background: rgba(0,0,0,0.7); padding: 8px; border-radius: 6px; font-size: 11px; font-family: 'Courier New', monospace;">
                    <div style="font-size: 13px; font-weight: bold; color: #ffffff;">Wonder World - Alpha.8.3.6</div>
                    <div style="margin-top: 4px; font-size: 10px; color: #cccccc;">Press F3 to toggle debug info</div>
                </div>
            `;
        }
    
        if (controlsEnabled) {
            if (gameMode === "spectator") {
                // Always flying. Skip gravity and collision:
                velocity.x -= velocity.x * 10 * delta;
                velocity.z -= velocity.z * 10 * delta;
                const accel = getMovementAcceleration(delta);
                velocity.x += accel.x;
                velocity.z += accel.z;
                yawObject.position.x += velocity.x * delta;
                yawObject.position.z += velocity.z * delta;
                // Vertical movement via flyUp/flyDown (speed = 30 u/sec)
                if (flyUp) { yawObject.position.y += 30 * delta; }
                if (flyDown) { yawObject.position.y -= 30 * delta; }
            } else {
                if (!isFlying) {
                    const inWater = isInWater();
                    
                    // Water physics
                    if (inWater) {
                        // Slower movement in water (5/2 times slower)
                        const waterMovementFactor = 0.4; // 1 / (5/2)
                        
                        // Reduced gravity and fall speed in water
                        const waterGravity = 9.8 * 1.5; // Reduced gravity
                        const waterDrag = 0.8; // Water resistance
                        
                        // Apply water physics
                        velocity.x -= velocity.x * 3 * delta; // More drag in water
                        velocity.z -= velocity.z * 3 * delta;
                        
                        // Gradually slow down if falling too fast
                        if (velocity.y < -waterGravity) {
                            velocity.y = THREE.MathUtils.lerp(velocity.y, -waterGravity, delta * 3);
                        } else {
                            velocity.y -= waterGravity * delta;
                        }
                        
                        // Handle vertical movement in water
                        if (KEY["Jump"]) {
                            // Float up when holding jump
                            velocity.y = Math.min(velocity.y + 20 * delta, 8);
                        } else {
                            // Slowly sink when not holding jump
                            velocity.y = Math.max(velocity.y - 10 * delta, -4);
                        }
                        
                        // Apply movement with water resistance
                        const accel = getMovementAcceleration(delta);
                        velocity.x += accel.x * waterMovementFactor;
                        velocity.z += accel.z * waterMovementFactor;
                        
                        // Apply water drag
                        velocity.multiplyScalar(waterDrag);
                        
                    } else {
                        // Normal physics
                        velocity.x -= velocity.x * 10 * delta;
                        velocity.z -= velocity.z * 10 * delta;
                        velocity.y -= 9.8 * 5 * delta; // Gravity
                        
                        const accel = getMovementAcceleration(delta);
                        velocity.x += accel.x;
                        velocity.z += accel.z;
                    }

                    yawObject.position.x += velocity.x * delta;
                    yawObject.position.z += velocity.z * delta;
                    resolveHorizontalCollisions();

                    const originalY = yawObject.position.y;
                    yawObject.position.y += velocity.y * delta;
                    if (collidesCylinder(yawObject.position.y, yawObject.position.x, yawObject.position.z)) {
                        if (velocity.y < 0) canJump = true;
                        yawObject.position.y = originalY;
                        velocity.y = 0;
                    }
                } else {
                    // Normal flying when toggled.
                    velocity.x -= velocity.x * 10 * delta;
                    velocity.z -= velocity.z * 10 * delta;
                    const accel = getMovementAcceleration(delta);
                    velocity.x += accel.x;
                    velocity.z += accel.z;
                    yawObject.position.x += velocity.x * delta;
                    yawObject.position.z += velocity.z * delta;
                    if (flyUp) { yawObject.position.y += 30 * delta; }
                    if (flyDown) { yawObject.position.y -= 30 * delta; }
                }
            }
            // Update chunks only when the player's chunk position changes
            let newChunkX = Math.floor(yawObject.position.x / CHUNK_SIZE);
            let newChunkZ = Math.floor(yawObject.position.z / CHUNK_SIZE);
            if (newChunkX !== lastPlayerChunkX || newChunkZ !== lastPlayerChunkZ) {
                updateChunks();
                lastPlayerChunkX = newChunkX;
                lastPlayerChunkZ = newChunkZ;
            }
        }
        
        // Process chunk loading queue
        processChunkQueue();
    
        // New underwater overlay update:
        const overlay = document.getElementById("underwater-overlay");
        // Check player's head position (using an offset relative to player height)
        const headY = Math.floor(yawObject.position.y + 0.8 * playerHeight);
        const blockAtHead = getBlockAt(Math.floor(yawObject.position.x), headY, Math.floor(yawObject.position.z));
        if (blockAtHead === BLOCK_TYPES.water) {
            overlay.style.display = "block";
        } else {
            overlay.style.display = "none";
        }

        // New water wavy camera effect:
        if (getBlockAt(Math.floor(yawObject.position.x), Math.floor(yawObject.position.y + 0.8 * playerHeight), Math.floor(yawObject.position.z)) === BLOCK_TYPES.water) {
            // Apply oscillation to cameraEffect rotation for a wavy effect
            cameraEffect.rotation.x = Math.sin(time * 0.005) * 0.02;
            cameraEffect.rotation.y = Math.cos(time * 0.005) * 0.02;
        } else {
            cameraEffect.rotation.set(0, 0, 0);
        }
    
        renderer.render(scene, camera);
    }

    // Setup Pause Screen Button Handlers
    const resumeBtn = document.getElementById('pause-resume');
    const settingsBtn = document.getElementById('pause-settings');
    const saveBtn = document.getElementById('pause-save');
    const quitBtn = document.getElementById('pause-quit');
    resumeBtn.addEventListener('click', () => {
        document.body.requestPointerLock();
    });
    // Replace Settings placeholder with FOV prompt
    settingsBtn.addEventListener('click', () => {
        const currentFov = camera.fov;
        const input = prompt('Set Field of View (FOV) between 10 and 150:', currentFov);
        const newFov = parseFloat(input);
        if (!isNaN(newFov) && newFov > 10 && newFov < 150) {
            camera.fov = newFov;
            camera.updateProjectionMatrix();
       
        } else if (input !== null) {
            alert('Invalid FOV value. Please enter a number between 10 and 150.');
        }
    });
    saveBtn.addEventListener('click', () => {
        // Placeholder for save functionality
        alert('Save feature is not implemented yet.');
    });
    quitBtn.addEventListener('click', () => {
               // Placeholder for quit functionality
        alert('Quit feature is not implemented yet.');
    });

    // Wait for saved world load before initialization and chunk generation
    loadSavedWorldPromise.then(() => {
        init();
    });
    
    // Expose GamePack utilities to global scope for debugging
    window.GamePackLoader = GamePackLoader;
    window.GamePackUtils = GamePackUtils;
    window.WATCHER = WATCHER;
    
    // Console commands for game pack management
    window.gamePackCommands = {
        // List all loaded packs
        listPacks() {
            console.log("Loaded Game Packs:", GamePackLoader.getPackNames());
            return GamePackLoader.getPackInfo();
        },
        
        // Show detailed pack info
        showPackInfo(packName = null) {
            if (packName) {
                const packData = GamePackLoader.getPackData(packName);
                if (packData) {
                    console.log(`=== ${packName} ===`);
                    console.log("Path:", packData.basePath);
                    console.log("Blocks:", Object.keys(packData.blocks));
                    console.log("Biomes:", Object.keys(packData.biomes));
                    console.log("Structures:", Object.keys(packData.structures));
                    console.log("Config:", packData.config);
                    return packData;
                } else {
                    console.log(`Pack "${packName}" not found`);
                    return null;
                }
            } else {
                return GamePackUtils.debugPackContents();
            }
        },
        
        // Reload a specific pack
        async reloadPack(packName) {
            try {
                console.log(`Reloading pack: ${packName}`);
                const result = await GamePackLoader.reloadPack(packName);
                applyGamePackData();
                console.log(`Successfully reloaded: ${packName}`);
                return result;
            } catch (error) {
                console.error(`Failed to reload pack "${packName}":`, error);
                return null;
            }
        },
        
        // Add a new pack to the watcher
        async addPack(packName) {
            if (!WATCHER.gamePacks.includes(packName)) {
                WATCHER.gamePacks.push(packName);
                try {
                    const result = await GamePackLoader.loadGamePack(packName);
                    applyGamePackData();
                    console.log(`Successfully added pack: ${packName}`);
                    return result;
                } catch (error) {
                    console.error(`Failed to add pack "${packName}":`, error);
                    // Remove from watcher if loading failed
                    const index = WATCHER.gamePacks.indexOf(packName);
                    if (index > -1) {
                        WATCHER.gamePacks.splice(index, 1);
                    }
                    return null;
                }
            } else {
                console.log(`Pack "${packName}" is already active`);
                return GamePackLoader.getPackData(packName);
            }
        },
        
        // Remove a pack from the watcher (except **Default**)
        removePack(packName) {
            if (packName === "**Default**") {
                console.error("Cannot remove the **Default** pack");
                return false;
            }
            
            const index = WATCHER.gamePacks.indexOf(packName);
            if (index > -1) {
                WATCHER.gamePacks.splice(index, 1);
                GamePackLoader.loadedPacks.delete(packName);
                console.log(`Removed pack: ${packName}`);
                applyGamePackData(); // Reapply remaining packs
                return true;
            } else {
                console.log(`Pack "${packName}" not found in watcher`);
                return false;
            }
        },
        
        // Show merged data
        showMergedData(dataType = 'all') {
            if (dataType === 'all') {
                console.log("Blocks:", GamePackLoader.getMergedData('blocks'));
                console.log("Biomes:", GamePackLoader.getMergedData('biomes'));
                console.log("Structures:", GamePackLoader.getMergedData('structures'));
            } else {
                console.log(`${dataType}:`, GamePackLoader.getMergedData(dataType));
            }
        }
    };
    
    // Log console commands info
    console.log("Game Pack Console Commands Available:");
    console.log("- gamePackCommands.listPacks() - List all loaded packs");
    console.log("- gamePackCommands.showPackInfo(packName) - Show detailed pack info");
    console.log("- gamePackCommands.reloadPack(packName) - Reload a specific pack");
    console.log("- gamePackCommands.addPack(packName) - Add and load a new pack");
    console.log("- gamePackCommands.removePack(packName) - Remove a pack");
    console.log("- gamePackCommands.showMergedData(type) - Show merged data");
    </script>
</body>
</html>
