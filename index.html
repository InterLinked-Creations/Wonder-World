<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Wonder World (Alpha)</title>
        <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        #info {
            position: absolute;
            top: 0;
            width: 100%;
            color: #fff;
            font-family: sans-serif;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            z-index: 1;
        }
        </style>
    </head>
    <body>
        <div id="info">
        Click to play - WASD to move, SPACE to jump. Left click to break, right click to place blocks.
        </div>
        <!-- Load Three.js from a CDN -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

        <!-- ImprovedNoise with Random Permutation -->
        <script>
        var ImprovedNoise = function () {
            var p = [];
            // Use a random permutation
            for (var i = 0; i < 256; i++) {
            p[i] = Math.floor(Math.random() * 256);
            }
            var permutation = new Array(512);
            for (var i = 0; i < 256; i++) {
            permutation[i] = p[i];
            permutation[i + 256] = p[i];
            }
            function fade(t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
            }
            function lerp(t, a, b) {
            return a + t * (b - a);
            }
            function grad(hash, x, y, z) {
            var h = hash & 15;
            var u = h < 8 ? x : y;
            var v = h < 4 ? y : (h === 12 || h === 14 ? x : z);
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
            return {
            noise: function (x, y, z) {
                var floorX = Math.floor(x),
                floorY = Math.floor(y),
                floorZ = Math.floor(z);
                var X = floorX & 255,
                Y = floorY & 255,
                Z = floorZ & 255;
                x -= floorX;
                y -= floorY;
                z -= floorZ;
                var u = fade(x),
                v = fade(y),
                w = fade(z);
                var A = permutation[X] + Y,
                AA = permutation[A] + Z,
                AB = permutation[A + 1] + Z;
                var B = permutation[X + 1] + Y,
                BA = permutation[B] + Z,
                BB = permutation[B + 1] + Z;
                return lerp(
                w,
                lerp(
                    v,
                    lerp(u, grad(permutation[AA], x, y, z), grad(permutation[BA], x - 1, y, z)),
                    lerp(u, grad(permutation[AB], x, y - 1, z), grad(permutation[BB], x - 1, y - 1, z))
                ),
                lerp(
                    v,
                    lerp(u, grad(permutation[AA + 1], x, y, z - 1), grad(permutation[BA + 1], x - 1, y, z - 1)),
                    lerp(u, grad(permutation[AB + 1], x, y - 1, z - 1), grad(permutation[BB + 1], x - 1, y - 1, z - 1))
                )
                );
            }
            };
        };
        </script>

        <!-- Main Game Script -->
        <script>
        /********************************************
         * Global Constants & Variables
         ********************************************/
        const CHUNK_SIZE = 50;         // Blocks per side of a chunk
        const WORLD_HEIGHT = 216;         // Vertical blocks per chunk
        const WORLD_CHUNK_COUNT = 100;    // World grid: 50 x 50 chunks
        const VISIBLE_RADIUS = 2;        // Load chunks within 5 chunks of the player

        // Block types:
        // 0 = Air
        // 1 = Stone
        // 2 = Dirt (surface)
        // 3 = Wood (trunk)
        // 4 = Leaves
        // 5 = Sand
        // 6 = Snow
        // Colors will be assigned per type.
        const blockColors = {
            1: new THREE.Color(0x888888),  // Stone: gray
            2: new THREE.Color(0x664422),  // Dirt: brownish
            3: new THREE.Color(0x885522),  // Wood: dark brown
            4: new THREE.Color(0x88cc88),  // Leaves: light green
            5: new THREE.Color(0xD2B48C),  // Sand: tan
            6: new THREE.Color(0xFFFFFF)   // Snow: white
        };

        // Player collision and movement parameters.
        const playerHeight = 1.8;        // Cylinder height
        const playerRadius = 0.3;        // Cylinder radius
        const jumpImpulse = 13;          // Jump impulse

        let scene, renderer;
        let camera, yawObject;
        let pitch = 0;
        let controlsEnabled = false;

        // Movement state.
        let velocity = new THREE.Vector3();
        let prevTime = performance.now();
        let moveForward = false,
            moveBackward = false,
            moveLeft = false,
            moveRight = false;
        let canJump = false;

        // NEW: Store last known player chunk coordinates
        let lastPlayerChunkX = null, lastPlayerChunkZ = null;

        // Dictionaries for chunk meshes and block data.
        let loadedChunks = {};    // keys: "cx,cz" -> mesh
        let chunkDataStore = {};  // keys: "cx,cz" -> 3D block array

        // Noise generator.
        const noiseGenerator = new ImprovedNoise();

        // For raycasting block interactions.
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        // Add new global variables for running detection:
        let lastWPressTime = 0;
        let isRunning = false;

        // Add touch controls for movement and look

        // Remove pointer lock if any touch event occurs:
        document.addEventListener("touchstart", function(e) {
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
        }, { passive: true });

        // BEGIN new 8-button movement controls and jump button

        // Create container for left directional buttons
        const leftControlContainer = document.createElement("div");
        leftControlContainer.style.position = "absolute";
        leftControlContainer.style.left = "20px";
        leftControlContainer.style.bottom = "20px";
        leftControlContainer.style.width = "150px";
        leftControlContainer.style.height = "150px";
        document.body.appendChild(leftControlContainer);

        // Define the 8 directions with corresponding vectors and angles.
        const directions = [
            { name: "forward", vx: 0, vy: -1, angle: 90 },
            { name: "forwardRight", vx: 1, vy: -1, angle: 45 },
            { name: "right", vx: 1, vy: 0, angle: 0 },
            { name: "backRight", vx: 1, vy: 1, angle: 315 },
            { name: "back", vx: 0, vy: 1, angle: 270 },
            { name: "backLeft", vx: -1, vy: 1, angle: 225 },
            { name: "left", vx: -1, vy: 0, angle: 180 },
            { name: "forwardLeft", vx: -1, vy: -1, angle: 135 }
        ];
        directions.forEach(dir => {
            const btn = document.createElement("div");
            btn.id = "btn-" + dir.name;
            btn.innerHTML = dir.name;
            btn.style.position = "absolute";
            btn.style.width = "40px";
            btn.style.height = "40px";
            btn.style.background = "rgba(0,0,0,0.5)";
            btn.style.color = "#fff";
            btn.style.textAlign = "center";
            btn.style.lineHeight = "40px";
            btn.style.borderRadius = "50%";
            // Position buttons on a circle within the container
            const radius = 50;
            const centerX = 75;
            const centerY = 75;
            const rad = dir.angle * Math.PI/180;
            btn.style.left = (centerX + radius * Math.cos(rad) - 20) + "px";
            btn.style.top = (centerY - radius * Math.sin(rad) - 20) + "px";
            // On touchstart, set movement flags according to the direction.
            btn.addEventListener("touchstart", function(e) {
                e.preventDefault();
                moveForward = (dir.vy < 0);
                moveBackward = (dir.vy > 0);
                moveRight = (dir.vx > 0);
                moveLeft = (dir.vx < 0);
            }, false);
            btn.addEventListener("touchend", function(e) {
                e.preventDefault();
                moveForward = moveBackward = moveRight = moveLeft = false;
            }, false);
            leftControlContainer.appendChild(btn);
        });

        // Create jump button on the right side
        const jumpButton = document.createElement("div");
        jumpButton.style.position = "absolute";
        jumpButton.style.right = "20px";
        jumpButton.style.bottom = "20px";
        jumpButton.style.width = "80px";
        jumpButton.style.height = "80px";
        jumpButton.style.background = "rgba(0,0,0,0.5)";
        jumpButton.style.borderRadius = "50%";
        jumpButton.style.textAlign = "center";
        jumpButton.style.lineHeight = "80px";
        jumpButton.style.fontSize = "20px";
        jumpButton.innerHTML = "Jump";
        document.body.appendChild(jumpButton);
        jumpButton.addEventListener("touchstart", function(e) {
            e.preventDefault();
            if (canJump) {
                velocity.y = jumpImpulse;
                canJump = false;
            }
        }, false);

        // Global screen touch for camera control (excluding the two button areas)
        let cameraTouchStart = null;
        document.addEventListener("touchstart", function(e) {
            if (e.target !== leftControlContainer &&
                e.target !== jumpButton &&
                e.target.parentNode !== leftControlContainer) {
                    cameraTouchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        }, false);
        document.addEventListener("touchmove", function(e) {
            if (cameraTouchStart &&
                e.target !== leftControlContainer &&
                e.target !== jumpButton &&
                e.target.parentNode !== leftControlContainer) {
                    let dx = e.touches[0].clientX - cameraTouchStart.x;
                    let dy = e.touches[0].clientY - cameraTouchStart.y;
                    yawObject.rotation.y -= dx * 0.005;
                    pitch -= dy * 0.005;
                    pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
                    camera.rotation.x = pitch;
                    cameraTouchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    e.preventDefault();
            }
        }, false);
        document.addEventListener("touchend", function(e) {
            cameraTouchStart = null;
        }, false);

        // END new touch button controls

        /********************************************
         * Cylinder-Based Collision Helpers
         ********************************************/
        function collidesCylinder(posY, posX, posZ) {
            const baseY = posY;
            const topY = posY + playerHeight;
            for (let bx = Math.floor(posX - playerRadius); bx <= Math.floor(posX + playerRadius); bx++) {
            for (let bz = Math.floor(posZ - playerRadius); bz <= Math.floor(posZ + playerRadius); bz++) {
                for (let by = Math.floor(baseY); by < Math.floor(topY) + 1; by++) {
                if (getBlockAt(bx, by, bz)) {
                    if ((by < topY) && (by + 1 > baseY)) {
                    const nearestX = Math.max(bx, Math.min(posX, bx + 1));
                    const nearestZ = Math.max(bz, Math.min(posZ, bz + 1));
                    const dx = posX - nearestX;
                    const dz = posZ - nearestZ;
                    if (Math.sqrt(dx * dx + dz * dz) < playerRadius) return true;
                    }
                }
                }
            }
            }
            return false;
        }

        function resolveHorizontalCollisions() {
            let iterations = 0;
            while (iterations < 5) {
            let posX = yawObject.position.x;
            let posZ = yawObject.position.z;
            let correction = new THREE.Vector2(0, 0);
            let collided = false;
            const baseY = yawObject.position.y;
            const topY = baseY + playerHeight;
            for (let bx = Math.floor(posX - playerRadius); bx <= Math.floor(posX + playerRadius); bx++) {
                for (let bz = Math.floor(posZ - playerRadius); bz <= Math.floor(posZ + playerRadius); bz++) {
                for (let by = Math.floor(baseY); by < Math.floor(topY) + 1; by++) {
                    if (getBlockAt(bx, by, bz)) {
                    if ((by < topY) && (by + 1 > baseY)) {
                        const nearestX = Math.max(bx, Math.min(posX, bx + 1));
                        const nearestZ = Math.max(bz, Math.min(posZ, bz + 1));
                        let dx = posX - nearestX;
                        let dz = posZ - nearestZ;
                        let dist = Math.sqrt(dx * dx + dz * dz);
                        if (dist < playerRadius) {
                        let overlap = playerRadius - dist;
                        if (dist === 0) {
                            dx = 0.01;
                            dz = 0.01;
                            dist = Math.sqrt(dx * dx + dz * dz);
                        }
                        const nx = dx / dist;
                        const nz = dz / dist;
                        correction.x += nx * overlap;
                        correction.y += nz * overlap;
                        collided = true;
                        }
                    }
                    }
                }
                }
            }
            if (collided) {
                yawObject.position.x += correction.x;
                yawObject.position.z += correction.y;
            } else {
                break;
            }
            iterations++;
            }
        }

        /********************************************
         * Block & Chunk Helpers
         ********************************************/
        // Returns the block value at global coordinate (1 = solid, 0 = air, or a type > 1)
        function getBlockAt(globalX, globalY, globalZ) {
            if (globalY < 0 || globalY >= WORLD_HEIGHT) return 0;
            const cx = Math.floor(globalX / CHUNK_SIZE);
            const cz = Math.floor(globalZ / CHUNK_SIZE);
            if (cx < 0 || cx >= WORLD_CHUNK_COUNT || cz < 0 || cz >= WORLD_CHUNK_COUNT) return 0;
            const key = `${cx},${cz}`;
            const chunkData = chunkDataStore[key];
            if (!chunkData) return 0;
            const localX = globalX - cx * CHUNK_SIZE;
            const localZ = globalZ - cz * CHUNK_SIZE;
            if (localX < 0 || localX >= CHUNK_SIZE || localZ < 0 || localZ >= CHUNK_SIZE)
            return 0;
            return chunkData[localX][globalY][localZ];
        }

        // Helper for chunk-local access
        function getBlockInChunk(chunkData, x, y, z) {
            if (x < 0 || x >= CHUNK_SIZE || y < 0 || y >= WORLD_HEIGHT || z < 0 || z >= CHUNK_SIZE)
            return 0;
            return chunkData[x][y][z];
        }

        // Cube face definitions.
        const faces = [
            { // Left face (-X)
            dir: [-1, 0, 0],
            vertices: [
                [0, 0, 1],
                [0, 1, 1],
                [0, 1, 0],
                [0, 0, 0],
            ]
            },
            { // Right face (+X)
            dir: [1, 0, 0],
            vertices: [
                [1, 0, 0],
                [1, 1, 0],
                [1, 1, 1],
                [1, 0, 1],
            ]
            },
            { // Bottom face (-Y)
            dir: [0, -1, 0],
            vertices: [
                [0, 0, 0],
                [1, 0, 0],
                [1, 0, 1],
                [0, 0, 1],
            ]
            },
            { // Top face (+Y)
            dir: [0, 1, 0],
            vertices: [
                [0, 1, 1],
                [1, 1, 1],
                [1, 1, 0],
                [0, 1, 0],
            ]
            },
            { // Back face (-Z)
            dir: [0, 0, -1],
            vertices: [
                [1, 0, 0],
                [0, 0, 0],
                [0, 1, 0],
                [1, 1, 0],
            ]
            },
            { // Front face (+Z)
            dir: [0, 0, 1],
            vertices: [
                [0, 0, 1],
                [1, 0, 1],
                [1, 1, 1],
                [0, 1, 1],
            ]
            }
        ];

        // Height function using improved noise.
        function getHeight(globalX, globalZ) {
            const frequency = 0.05;
            let noiseVal = noiseGenerator.noise(globalX * frequency, 0, globalZ * frequency);
            return Math.floor(((noiseVal + 1) / 2) * (WORLD_HEIGHT - 1));
        }

        // Use low-frequency noise for biome selection (desert, plains, snow, mountain)
        function getBiomeValue(globalX, globalZ) {
            return noiseGenerator.noise(globalX * 0.001, 0, globalZ * 0.001); // ~[-1,1], smooth over long distances
        }

        function getBiome(globalX, globalZ) {
            let b = getBiomeValue(globalX, globalZ);
            if (b < 0) return "ocean"; // Ocean biome for very low noise values
            if (b > 0.6) return "mountains";
            if (b > 0.3) return "desert";
            if (b > -0.3) return "plains";
            return "snow";
        }

        // Smooth transition: plains, desert, and snow share the same base height; mountains add a smooth offset.
        function getHeightWithBiome(globalX, globalZ) {
            if (getBiome(globalX, globalZ) === "ocean") {
                return 10; // Ocean biome: low, deep terrain
            }
            let nPrimary = noiseGenerator.noise(globalX * 0.1, 0, globalZ * 0.1);  // roughly [-1,1]
            let basePlain = 55;  // Adjusted from 425 to a more reasonable value for terrain generation
            let plainHeight = basePlain + nPrimary * 4;  // gentle slopes

            // Use biome noise to add mountain offset if applicable.
            let b = getBiomeValue(globalX, globalZ);
            if (b > 0.6) {
                let smoothFactor = (b - 0.6) / (1 - 0.6);
                if (b > 0.8) {
                    return Math.floor(plainHeight + smoothFactor * 50); // Giant mountain offset
                }
                return Math.floor(plainHeight + smoothFactor * 25); // Regular mountain
            } else {
                return Math.floor(plainHeight);
            }
        }

        /********************************************
         * Tree Generation in Chunk Data
         ********************************************/
        // Generates the block data for a single chunk.
        // Generates ground and—with a small chance—a tree on some columns.
        function generateChunkData(cx, cz) {
            // Create a 3D array: data[x][y][z]
            const data = [];
            for (let x = 0; x < CHUNK_SIZE; x++) {
            data[x] = [];
            for (let y = 0; y < WORLD_HEIGHT; y++) {
                data[x][y] = [];
                for (let z = 0; z < CHUNK_SIZE; z++) {
                data[x][y][z] = 0;
                }
            }
            }
            // For each column (x,z) in the chunk:
            for (let x = 0; x < CHUNK_SIZE; x++) {
            for (let z = 0; z < CHUNK_SIZE; z++) {
                let globalX = cx * CHUNK_SIZE + x;
                let globalZ = cz * CHUNK_SIZE + z;
                let biome = getBiome(globalX, globalZ);
                let h = getHeightWithBiome(globalX, globalZ);
                if (h >= WORLD_HEIGHT) h = WORLD_HEIGHT - 1;
                if (biome === "ocean") {
                    // Ocean biome: fill entire column with sand for a deep, sandy floor.
                    for (let y = 0; y <= h; y++) {
                        data[x][y][z] = 5; // Sand
                    }
                } else {
                    // Fill lower layers with stone.
                    for (let y = 0; y < h; y++) {
                    data[x][y][z] = 1; // Stone
                    }
                    // Set the top block based on biome:
                    if (biome === "desert") {
                        data[x][h][z] = 5; // Sand
                    } else if (biome === "snow") {
                        data[x][h][z] = 6; // Snow
                    } else if (biome === "mountain") {
                        data[x][h][z] = 1; // Rugged surface (stone)
                    } else {
                        data[x][h][z] = 2; // Dirt for plains
                    }
                    
                    // NEW: Carve caves in non-ocean biomes so they reach the surface.
                    // Adjust cave frequency and size by modifying noise thresholds and parameters
                    const caveFrequency = 0.05; // Lower frequency for less frequent caves
                    const caveThreshold = 0.15; // Higher threshold for smaller caves

                    // Update cave generation logic
                    for (let y = 1; y < h; y++) {
                        if ((data[x][y][z] === 1 || data[x][y][z] === 2) &&
                            noiseGenerator.noise(globalX * caveFrequency, y * caveFrequency, globalZ * caveFrequency) > caveThreshold) {
                            data[x][y][z] = 0;
                        }
                    }
                }
            }
            }
            // Smoothing pass to create more continuous, tunnel-like caves.
            for (let x = 1; x < CHUNK_SIZE - 1; x++) {
                for (let y = 1; y < WORLD_HEIGHT - 1; y++) {
                    for (let z = 1; z < CHUNK_SIZE - 1; z++) {
                        if (data[x][y][z] !== 0) {
                            let airCount = 0;
                            for (let dx = -1; dx <= 1; dx++) {
                                for (let dy = -1; dy <= 1; dy++) {
                                    for (let dz = -1; dz <= 1; dz++) {
                                        if (data[x + dx][y + dy][z + dz] === 0) {
                                            airCount++;
                                        }
                                    }
                                }
                            }
                            // If more than half of the neighbors are air, clear this block.
                            if (airCount > 12) {
                                data[x][y][z] = 0;
                            }
                        }
                    }
                }
            }
            // NEW: Generate trees for plains biome after cave carving
            for (let x = 2; x < CHUNK_SIZE - 2; x++) {
                for (let z = 2; z < CHUNK_SIZE - 2; z++) {
                    let globalX = cx * CHUNK_SIZE + x;
                    let globalZ = cz * CHUNK_SIZE + z;
                    if (getBiome(globalX, globalZ) === "plains" && Math.random() < 0.04) {
                        // Find the highest solid block in this column.
                        let topY = 0;
                        for (let y = WORLD_HEIGHT - 1; y >= 0; y--) {
                            if (data[x][y][z] !== 0) {
                                topY = y;
                                break;
                            }
                        }
                        // Generate tree only if the top block is dirt and there's space.
                        if (data[x][topY][z] === 2 && topY + 6 < WORLD_HEIGHT) {
                            const trunkHeight = Math.floor(Math.random() * 3) + 4; // 4-6 blocks tall
                            for (let i = 1; i <= trunkHeight; i++) {
                                data[x][topY + i][z] = 3; // Wood
                            }
                            // Generate canopy.
                            for (let dy = trunkHeight; dy <= trunkHeight + 1; dy++) {
                                if (topY + dy >= WORLD_HEIGHT) continue;
                                for (let dx = -1; dx <= 1; dx++) {
                                    for (let dz = -1; dz <= 1; dz++) {
                                        const tx = x + dx;
                                        const tz = z + dz;
                                        if (tx >= 0 && tx < CHUNK_SIZE && tz >= 0 && tz < CHUNK_SIZE) {
                                            data[tx][topY + dy][tz] = 4; // Leaves
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return data;
        }

        /********************************************
         * Build Chunk Geometry with Vertex Colors
         ********************************************/
        function buildChunkGeometry(chunkData, cx, cz) {
            const vertices = [];
            const indices = [];
            const uvs = [];
            const colors = [];
            let vertexCount = 0;

            for (let x = 0; x < CHUNK_SIZE; x++) {
            for (let y = 0; y < WORLD_HEIGHT; y++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                let blockType = chunkData[x][y][z];
                if (blockType === 0) continue;

                // For each face, check if the neighbor is air.
                for (let f = 0; f < faces.length; f++) {
                    const face = faces[f];
                    const nx = x + face.dir[0];
                    const ny = y + face.dir[1];
                    const nz = z + face.dir[2];
                    if (getBlockInChunk(chunkData, nx, ny, nz) !== 0) continue;

                    // Add face vertices.
                    for (let i = 0; i < 4; i++) {
                    const vertex = face.vertices[i];
                    vertices.push(
                        cx * CHUNK_SIZE + x + vertex[0],
                        y + vertex[1],
                        cz * CHUNK_SIZE + z + vertex[2]
                    );
                    // Push the color corresponding to blockType.
                    let col = blockColors[blockType];
                    colors.push(col.r, col.g, col.b);
                    }
                    uvs.push(0, 0, 1, 0, 1, 1, 0, 1);
                    indices.push(
                    vertexCount, vertexCount + 1, vertexCount + 2,
                    vertexCount, vertexCount + 2, vertexCount + 3
                    );
                    vertexCount += 4;
                }
                }
            }
            }
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute("uv", new THREE.Float32BufferAttribute(uvs, 2));
            geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            return geometry;
        }

        /********************************************
         * Chunk Management
         ********************************************/
        function loadChunk(cx, cz) {
            const key = `${cx},${cz}`;
            if (loadedChunks[key]) return;
            const chunkData = generateChunkData(cx, cz);
            chunkDataStore[key] = chunkData;
            const geometry = buildChunkGeometry(chunkData, cx, cz);
            const material = new THREE.MeshLambertMaterial({
            vertexColors: true,
            side: THREE.FrontSide
            });
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            loadedChunks[key] = mesh;
        }

        function unloadChunk(cx, cz) {
            const key = `${cx},${cz}`;
            if (loadedChunks[key]) {
            scene.remove(loadedChunks[key]);
            loadedChunks[key].geometry.dispose();
            loadedChunks[key].material.dispose();
            delete loadedChunks[key];
            delete chunkDataStore[key];
            }
        }

        function updateChunk(cx, cz) {
            const key = `${cx},${cz}`;
            if (!chunkDataStore[key]) return;
            if (loadedChunks[key]) {
            scene.remove(loadedChunks[key]);
            loadedChunks[key].geometry.dispose();
            loadedChunks[key].material.dispose();
            }
            const geometry = buildChunkGeometry(chunkDataStore[key], cx, cz);
            const material = new THREE.MeshLambertMaterial({
            vertexColors: true,
            side: THREE.FrontSide
            });
            material.castShadow = true;
            material.receiveShadow = true;
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            loadedChunks[key] = mesh;
        }

        function updateChunks() {
            const playerPos = yawObject.position;
            let playerChunkX = Math.floor(playerPos.x / CHUNK_SIZE);
            let playerChunkZ = Math.floor(playerPos.z / CHUNK_SIZE);
            playerChunkX = Math.max(0, Math.min(WORLD_CHUNK_COUNT - 1, playerChunkX));
            playerChunkZ = Math.max(0, Math.min(WORLD_CHUNK_COUNT - 1, playerChunkZ));

            for (let cx = playerChunkX - VISIBLE_RADIUS; cx <= playerChunkX + VISIBLE_RADIUS; cx++) {
            for (let cz = playerChunkZ - VISIBLE_RADIUS; cz <= playerChunkZ + VISIBLE_RADIUS; cz++) {
                if (cx < 0 || cx >= WORLD_CHUNK_COUNT || cz < 0 || cz >= WORLD_CHUNK_COUNT) continue;
                loadChunk(cx, cz);
            }
            }
            for (const key in loadedChunks) {
            const [cx, cz] = key.split(",").map(Number);
            const dx = cx - playerChunkX;
            const dz = cz - playerChunkZ;
            if (Math.sqrt(dx * dx + dz * dz) > VISIBLE_RADIUS + 0.5) {
                unloadChunk(cx, cz);
            }
            }
        }

        /********************************************
         * Block Modification (Place / Break)
         ********************************************/
        function modifyBlockAt(worldPos, value) {
            const gx = Math.floor(worldPos.x);
            const gy = Math.floor(worldPos.y);
            const gz = Math.floor(worldPos.z);
            const cx = Math.floor(gx / CHUNK_SIZE);
            const cz = Math.floor(gz / CHUNK_SIZE);
            const key = `${cx},${cz}`;
            if (!chunkDataStore[key]) {
            console.log("Chunk not loaded. Cannot modify block.");
            return;
            }
            const localX = gx - cx * CHUNK_SIZE;
            const localZ = gz - cz * CHUNK_SIZE;
            if (
            localX < 0 || localX >= CHUNK_SIZE ||
            gy < 0 || gy >= WORLD_HEIGHT ||
            localZ < 0 || localZ >= CHUNK_SIZE
            ) {
            console.log("Block coordinates out of range.");
            return;
            }
            chunkDataStore[key][localX][gy][localZ] = value;
            updateChunk(cx, cz);
        }

        /********************************************
         * Initialization & Rendering
         ********************************************/
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x88ccff);
            scene.fog = new THREE.Fog(0x88ccff, 0, 150);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 0.5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -8;
            directionalLight.shadow.camera.right = 8;
            directionalLight.shadow.camera.top = 8;
            directionalLight.shadow.camera.bottom = -8;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);

            // Set up camera and first-person hierarchy.
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // Position the camera at 80% of the cylinder height (simulating the head).
            camera.position.set(0, 0.8 * playerHeight, 0);
            yawObject = new THREE.Object3D();
            
            // Place the player near the center of the world; get ground height at starting x/z.
            let startX = (WORLD_CHUNK_COUNT * CHUNK_SIZE) / 2;
            let startZ = (WORLD_CHUNK_COUNT * CHUNK_SIZE) / 2;
            // If the default position is ocean, offset coordinates to land
            if (getBiome(startX, startZ) === "ocean") {
                startX += CHUNK_SIZE;
                startZ += CHUNK_SIZE;
            }
            let groundY = getHeightWithBiome(startX, startZ);
            yawObject.position.set(startX, groundY + playerHeight, startZ);
            yawObject.add(camera);
            scene.add(yawObject);
            
            // Preload visible chunks so the world is ready.
            updateChunks();
            
            // Setup Pointer Lock.
            const element = document.body;
            element.addEventListener("click", function () {
            element.requestPointerLock();
            });
            document.addEventListener("pointerlockchange", onPointerLockChange, false);
            document.addEventListener("pointerlockerror", onPointerLockError, false);
            document.addEventListener("mousemove", onMouseMove, false);
            document.addEventListener("mousedown", onMouseDown, false);
            window.addEventListener("keydown", onKeyDown, false);
            window.addEventListener("keyup", onKeyUp, false);
            window.addEventListener("resize", onWindowResize, false);

            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onPointerLockChange() {
            controlsEnabled = (document.pointerLockElement === document.body);
        }
        function onPointerLockError() {
            console.error("PointerLock Error");
        }
        function onMouseMove(event) {
            if (!controlsEnabled) return;
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;
            yawObject.rotation.y -= movementX * 0.002;
            pitch -= movementY * 0.002;
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
            camera.rotation.x = pitch;
        }

        function getMovementAcceleration(delta) {
            const forward = new THREE.Vector3(0, 0, -1)
            .applyAxisAngle(new THREE.Vector3(0, 1, 0), yawObject.rotation.y);
            const right = new THREE.Vector3(1, 0, 0)
            .applyAxisAngle(new THREE.Vector3(0, 1, 0), yawObject.rotation.y);
            const accel = new THREE.Vector3();
            if (moveForward) accel.add(forward);
            if (moveBackward) accel.sub(forward);
            if (moveLeft) accel.sub(right);
            if (moveRight) accel.add(right);
            if (accel.length() > 0) {
                // Use a higher multiplier when running.
                accel.normalize().multiplyScalar((isRunning ? 70 : 40) * delta);
            }
            return accel;
        }

        function onKeyDown(event) {
            const currentTime = performance.now();
            switch (event.code) {
            case "KeyW":
            case "ArrowUp":
                if (!moveForward && (currentTime - lastWPressTime < 300)) {
                    isRunning = true;
                }
                lastWPressTime = currentTime;
                moveForward = true;
                break;
            case "KeyS":
            case "ArrowDown":
                moveBackward = true;
                break;
            case "KeyA":
            case "ArrowLeft":
                moveLeft = true;
                break;
            case "KeyD":
            case "ArrowRight":
                moveRight = true;
                break;
            case "Space":
                if (canJump) {
                velocity.y = jumpImpulse;
                canJump = false;
                }
                break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
            case "KeyW":
            case "ArrowUp":
                moveForward = false;
                isRunning = false;
                break;
            case "KeyS":
            case "ArrowDown":
                moveBackward = false;
                break;
            case "KeyA":
            case "ArrowLeft":
                moveLeft = false;
                break;
            case "KeyD":
            case "ArrowRight":
                moveRight = false;
                break;
            }
        }

        /********************************************
         * Block Interaction via Raycasting
         ********************************************/
        // Cast a ray from the center of the camera. For left-click (break)
        // subtract a tiny offset; for right-click (place) add ~0.51 along the face normal.
        function onMouseDown(event) {
            if (!controlsEnabled) return;
            pointer.set(0, 0);
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(Object.values(loadedChunks));
            if (intersects.length > 0) {
            const intersect = intersects[0];
            if (event.button === 0) { // Left click: break block.
                const breakPos = new THREE.Vector3(
                Math.floor(intersect.point.x - intersect.face.normal.x * 0.01),
                Math.floor(intersect.point.y - intersect.face.normal.y * 0.01),
                Math.floor(intersect.point.z - intersect.face.normal.z * 0.01)
                );
                modifyBlockAt(breakPos, 0);
            } else if (event.button === 2) { // Right click: place block.
                const placePos = new THREE.Vector3(
                Math.floor(intersect.point.x + intersect.face.normal.x * 0.51),
                Math.floor(intersect.point.y + intersect.face.normal.y * 0.51),
                Math.floor(intersect.point.z + intersect.face.normal.z * 0.51)
                );
                modifyBlockAt(placePos, 2); // Place a dirt block by default.
                // You could modify this to allow players to select which material to place.
            }
            }
        }
        document.addEventListener("contextmenu", function (e) { e.preventDefault(); });

        /********************************************
         * Animation, Physics & Collision Loop
         ********************************************/
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            // Cap delta to avoid glitches on dropped frames
            const delta = Math.min((time - prevTime) / 1000, 0.1);
            prevTime = time;

            if (controlsEnabled) {
            velocity.x -= velocity.x * 10 * delta;
            velocity.z -= velocity.z * 10 * delta;
            velocity.y -= 9.8 * 5 * delta; // Gravity

            const accel = getMovementAcceleration(delta);
            velocity.x += accel.x;
            velocity.z += accel.z;

            yawObject.position.x += velocity.x * delta;
            yawObject.position.z += velocity.z * delta;
            resolveHorizontalCollisions();

            const originalY = yawObject.position.y;
            yawObject.position.y += velocity.y * delta;
            if (collidesCylinder(yawObject.position.y, yawObject.position.x, yawObject.position.z)) {
                if (velocity.y < 0) canJump = true;
                yawObject.position.y = originalY;
                velocity.y = 0;
            }
            // Update chunks only when the player's chunk position changes.
            let newChunkX = Math.floor(yawObject.position.x / CHUNK_SIZE);
            let newChunkZ = Math.floor(yawObject.position.z / CHUNK_SIZE);
            if (newChunkX !== lastPlayerChunkX || newChunkZ !== lastPlayerChunkZ) {
                updateChunks();
                lastPlayerChunkX = newChunkX;
                lastPlayerChunkZ = newChunkZ;
            }
            }

            // Safety check: if the player falls too far below the world, respawn them
            if (yawObject.position.y < -50) {
            const currentGroundY = getHeight(yawObject.position.x, yawObject.position.z);
            yawObject.position.y = currentGroundY + playerHeight;
            velocity.set(0, 0, 0);
            canJump = false;
            }

            renderer.render(scene, camera);
        }

        init();
        </script>
    </body>
    </html>
